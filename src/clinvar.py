#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 30 11:14:08 2015 by generateDS.py version 2.15a.
#
# Command line options:
#   ('-o', 'clinvar.py')
#   ('-s', 'clinvarsubs.py')
#
# Command line arguments:
#   /home/cwu/Desktop/clinvar_public.xsd
#
# Command line:
#   /home/cwu/opt/devpy/bin/generateDS.py -o "clinvar.py" -s "clinvarsubs.py" /home/cwu/Desktop/clinvar_public.xsd
#
# Current working directory (os.getcwd()):
#   mygene.info_py3
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(*args, **kwargs):
    if 'parser' not in kwargs:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

# ExternalEncoding = 'ascii'
ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class XrefType(GeneratedsSuper):
    """This structure is used to represent how an object described in the
    submission relates to objects in other databases. The name of
    the database. When there is an overlap with sequence databases,
    that name is used.The identifier used by the database. Being
    exported as a string even though internally the database has
    rules for defining which datases use integer identifers.Used to
    differentiate between different types of identifers that a
    database may provide."""
    subclass = None
    superclass = None
    def __init__(self, URL=None, Type=None, DB=None, ID=None, Status='current'):
        self.original_tagname_ = None
        self.URL = _cast(None, URL)
        self.Type = _cast(None, Type)
        self.DB = _cast(None, DB)
        self.ID = _cast(None, ID)
        self.Status = _cast(None, Status)
    def factory(*args_, **kwargs_):
        if XrefType.subclass:
            return XrefType.subclass(*args_, **kwargs_)
        else:
            return XrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject', 'secondary', 'suppressed', 'under review']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeStatus' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XrefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XrefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XrefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XrefType'):
        if self.URL is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            outfile.write(' URL=%s' % (self.gds_format_string(quote_attrib(self.URL).encode(ExternalEncoding), input_name='URL'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.DB is not None and 'DB' not in already_processed:
            already_processed.add('DB')
            outfile.write(' DB=%s' % (self.gds_format_string(quote_attrib(self.DB).encode(ExternalEncoding), input_name='DB'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
    def exportChildren(self, outfile, level, namespace_='', name_='XrefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='XrefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.URL is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            showIndent(outfile, level)
            outfile.write('URL="%s",\n' % (self.URL,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.DB is not None and 'DB' not in already_processed:
            already_processed.add('DB')
            showIndent(outfile, level)
            outfile.write('DB="%s",\n' % (self.DB,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID="%s",\n' % (self.ID,))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            showIndent(outfile, level)
            outfile.write('Status="%s",\n' % (self.Status,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URL', node)
        if value is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            self.URL = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('DB', node)
        if value is not None and 'DB' not in already_processed:
            already_processed.add('DB')
            self.DB = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)    # validate type typeStatus
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class XrefType


class CitationType(GeneratedsSuper):
    """This maintained distinct from publication types in PubMed and
    established by GTR curators. The default is
    'general'.Corresponds to the abbreviation reported by GTR."""
    subclass = None
    superclass = None
    def __init__(self, Abbrev=None, Type=None, ID=None, URL=None, CitationText=None):
        self.original_tagname_ = None
        self.Abbrev = _cast(None, Abbrev)
        self.Type = _cast(None, Type)
        self.ID = ID
        self.URL = URL
        self.CitationText = CitationText
    def factory(*args_, **kwargs_):
        if CitationType.subclass:
            return CitationType.subclass(*args_, **kwargs_)
        else:
            return CitationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_CitationText(self): return self.CitationText
    def set_CitationText(self, CitationText): self.CitationText = CitationText
    def get_Abbrev(self): return self.Abbrev
    def set_Abbrev(self, Abbrev): self.Abbrev = Abbrev
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.ID is not None or
            self.URL is not None or
            self.CitationText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CitationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CitationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CitationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CitationType'):
        if self.Abbrev is not None and 'Abbrev' not in already_processed:
            already_processed.add('Abbrev')
            outfile.write(' Abbrev=%s' % (self.gds_format_string(quote_attrib(self.Abbrev).encode(ExternalEncoding), input_name='Abbrev'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CitationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            self.ID.export(outfile, level, namespace_, name_='ID', pretty_print=pretty_print)
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        if self.CitationText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCitationText>%s</%sCitationText>%s' % (namespace_, self.gds_format_string(quote_xml(self.CitationText).encode(ExternalEncoding), input_name='CitationText'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CitationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbrev is not None and 'Abbrev' not in already_processed:
            already_processed.add('Abbrev')
            showIndent(outfile, level)
            outfile.write('Abbrev="%s",\n' % (self.Abbrev,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=model_.IDType(\n')
            self.ID.exportLiteral(outfile, level, name_='ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.CitationText is not None:
            showIndent(outfile, level)
            outfile.write('CitationText=%s,\n' % quote_python(self.CitationText).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbrev', node)
        if value is not None and 'Abbrev' not in already_processed:
            already_processed.add('Abbrev')
            self.Abbrev = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            obj_ = IDType.factory()
            obj_.build(child_)
            self.ID = obj_
            obj_.original_tagname_ = 'ID'
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'CitationText':
            CitationText_ = child_.text
            CitationText_ = self.gds_validate_string(CitationText_, node, 'CitationText')
            self.CitationText = CitationText_
# end class CitationType


class CommentType(GeneratedsSuper):
    """A structure to support reporting unformatted content."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, DataSource=None, valueOf_=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.DataSource = _cast(None, DataSource)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CommentType.subclass:
            return CommentType.subclass(*args_, **kwargs_)
        else:
            return CommentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_DataSource(self): return self.DataSource
    def set_DataSource(self, DataSource): self.DataSource = DataSource
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_CommentTypeList(self, value):
        # Validate type CommentTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['public', 'ConvertedByNCBI', 'MissingFromAssembly', 'GenomicLocationNotEstablished', 'LocationOnGenomeAndProductNotAligned']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommentTypeList' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommentType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.DataSource is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            outfile.write(' DataSource=%s' % (self.gds_format_string(quote_attrib(self.DataSource).encode(ExternalEncoding), input_name='DataSource'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CommentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CommentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.DataSource is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            showIndent(outfile, level)
            outfile.write('DataSource="%s",\n' % (self.DataSource,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_CommentTypeList(self.Type)    # validate type CommentTypeList
        value = find_attr_value_('DataSource', node)
        if value is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            self.DataSource = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommentType


class DataSourceType(GeneratedsSuper):
    """A standard term for the source of the informationThe identifier used
    by the data sourceControlled terms to categorize the source of
    the information"""
    subclass = None
    superclass = None
    def __init__(self, SourceType=None, DataSource=None, ID=None):
        self.original_tagname_ = None
        self.SourceType = _cast(None, SourceType)
        self.DataSource = _cast(None, DataSource)
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if DataSourceType.subclass:
            return DataSourceType.subclass(*args_, **kwargs_)
        else:
            return DataSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_DataSource(self): return self.DataSource
    def set_DataSource(self, DataSource): self.DataSource = DataSource
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataSourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataSourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSourceType'):
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            outfile.write(' SourceType=%s' % (self.gds_format_string(quote_attrib(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), ))
        if self.DataSource is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            outfile.write(' DataSource=%s' % (self.gds_format_string(quote_attrib(self.DataSource).encode(ExternalEncoding), input_name='DataSource'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataSourceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DataSourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SourceType is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            showIndent(outfile, level)
            outfile.write('SourceType="%s",\n' % (self.SourceType,))
        if self.DataSource is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            showIndent(outfile, level)
            outfile.write('DataSource="%s",\n' % (self.DataSource,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID="%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SourceType', node)
        if value is not None and 'SourceType' not in already_processed:
            already_processed.add('SourceType')
            self.SourceType = value
        value = find_attr_value_('DataSource', node)
        if value is not None and 'DataSource' not in already_processed:
            already_processed.add('DataSource')
            self.DataSource = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataSourceType


class PublicSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DateLastUpdated=None, RecordStatus='current', ReplacedBy=None, Replaces=None, Title=None, ReferenceClinVarAssertion=None, ClinVarAssertion=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DateLastUpdated = _cast(None, DateLastUpdated)
        self.RecordStatus = RecordStatus
        self.validate_RecordStatusType(self.RecordStatus)
        self.ReplacedBy = ReplacedBy
        if Replaces is None:
            self.Replaces = []
        else:
            self.Replaces = Replaces
        self.Title = Title
        self.ReferenceClinVarAssertion = ReferenceClinVarAssertion
        if ClinVarAssertion is None:
            self.ClinVarAssertion = []
        else:
            self.ClinVarAssertion = ClinVarAssertion
    def factory(*args_, **kwargs_):
        if PublicSetType.subclass:
            return PublicSetType.subclass(*args_, **kwargs_)
        else:
            return PublicSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecordStatus(self): return self.RecordStatus
    def set_RecordStatus(self, RecordStatus): self.RecordStatus = RecordStatus
    def get_ReplacedBy(self): return self.ReplacedBy
    def set_ReplacedBy(self, ReplacedBy): self.ReplacedBy = ReplacedBy
    def get_Replaces(self): return self.Replaces
    def set_Replaces(self, Replaces): self.Replaces = Replaces
    def add_Replaces(self, value): self.Replaces.append(value)
    def insert_Replaces_at(self, index, value): self.Replaces.insert(index, value)
    def replace_Replaces_at(self, index, value): self.Replaces[index] = value
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_ReferenceClinVarAssertion(self): return self.ReferenceClinVarAssertion
    def set_ReferenceClinVarAssertion(self, ReferenceClinVarAssertion): self.ReferenceClinVarAssertion = ReferenceClinVarAssertion
    def get_ClinVarAssertion(self): return self.ClinVarAssertion
    def set_ClinVarAssertion(self, ClinVarAssertion): self.ClinVarAssertion = ClinVarAssertion
    def add_ClinVarAssertion(self, value): self.ClinVarAssertion.append(value)
    def insert_ClinVarAssertion_at(self, index, value): self.ClinVarAssertion.insert(index, value)
    def replace_ClinVarAssertion_at(self, index, value): self.ClinVarAssertion[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DateLastUpdated(self): return self.DateLastUpdated
    def set_DateLastUpdated(self, DateLastUpdated): self.DateLastUpdated = DateLastUpdated
    def validate_RecordStatusType(self, value):
        # Validate type RecordStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['current', 'replaced', 'removed', 'not current']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecordStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RecordStatus is not None or
            self.ReplacedBy is not None or
            self.Replaces or
            self.Title is not None or
            self.ReferenceClinVarAssertion is not None or
            self.ClinVarAssertion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PublicSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PublicSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PublicSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PublicSetType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            outfile.write(' DateLastUpdated=%s' % (self.gds_format_string(quote_attrib(self.DateLastUpdated).encode(ExternalEncoding), input_name='DateLastUpdated'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PublicSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RecordStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordStatus>%s</%sRecordStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.RecordStatus).encode(ExternalEncoding), input_name='RecordStatus'), namespace_, eol_))
        if self.ReplacedBy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReplacedBy>%s</%sReplacedBy>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReplacedBy).encode(ExternalEncoding), input_name='ReplacedBy'), namespace_, eol_))
        for Replaces_ in self.Replaces:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReplaces>%s</%sReplaces>%s' % (namespace_, self.gds_format_string(quote_xml(Replaces_).encode(ExternalEncoding), input_name='Replaces'), namespace_, eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.ReferenceClinVarAssertion is not None:
            self.ReferenceClinVarAssertion.export(outfile, level, namespace_, name_='ReferenceClinVarAssertion', pretty_print=pretty_print)
        for ClinVarAssertion_ in self.ClinVarAssertion:
            ClinVarAssertion_.export(outfile, level, namespace_, name_='ClinVarAssertion', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PublicSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            showIndent(outfile, level)
            outfile.write('DateLastUpdated="%s",\n' % (self.DateLastUpdated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RecordStatus is not None:
            showIndent(outfile, level)
            outfile.write('RecordStatus=%s,\n' % quote_python(self.RecordStatus).encode(ExternalEncoding))
        if self.ReplacedBy is not None:
            showIndent(outfile, level)
            outfile.write('ReplacedBy=%s,\n' % quote_python(self.ReplacedBy).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Replaces=[\n')
        level += 1
        for Replaces_ in self.Replaces:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Replaces_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.ReferenceClinVarAssertion is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceClinVarAssertion=model_.ReferenceClinVarAssertion(\n')
            self.ReferenceClinVarAssertion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ClinVarAssertion=[\n')
        level += 1
        for ClinVarAssertion_ in self.ClinVarAssertion:
            showIndent(outfile, level)
            outfile.write('model_.ClinVarAssertion(\n')
            ClinVarAssertion_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('DateLastUpdated', node)
        if value is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            self.DateLastUpdated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecordStatus':
            RecordStatus_ = child_.text
            RecordStatus_ = self.gds_validate_string(RecordStatus_, node, 'RecordStatus')
            self.RecordStatus = RecordStatus_
            self.validate_RecordStatusType(self.RecordStatus)    # validate type RecordStatusType
        elif nodeName_ == 'ReplacedBy':
            ReplacedBy_ = child_.text
            ReplacedBy_ = self.gds_validate_string(ReplacedBy_, node, 'ReplacedBy')
            self.ReplacedBy = ReplacedBy_
        elif nodeName_ == 'Replaces':
            Replaces_ = child_.text
            Replaces_ = self.gds_validate_string(Replaces_, node, 'Replaces')
            self.Replaces.append(Replaces_)
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'ReferenceClinVarAssertion':
            obj_ = ReferenceAssertionType.factory()
            obj_.build(child_)
            self.ReferenceClinVarAssertion = obj_
            obj_.original_tagname_ = 'ReferenceClinVarAssertion'
        elif nodeName_ == 'ClinVarAssertion':
            obj_ = MeasureTraitType.factory()
            obj_.build(child_)
            self.ClinVarAssertion.append(obj_)
            obj_.original_tagname_ = 'ClinVarAssertion'
# end class PublicSetType


class ReleaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Dated=None, ClinVarSet=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        if isinstance(Dated, basestring):
            initvalue_ = datetime_.datetime.strptime(Dated, '%Y-%m-%d').date()
        else:
            initvalue_ = Dated
        self.Dated = initvalue_
        if ClinVarSet is None:
            self.ClinVarSet = []
        else:
            self.ClinVarSet = ClinVarSet
    def factory(*args_, **kwargs_):
        if ReleaseType.subclass:
            return ReleaseType.subclass(*args_, **kwargs_)
        else:
            return ReleaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClinVarSet(self): return self.ClinVarSet
    def set_ClinVarSet(self, ClinVarSet): self.ClinVarSet = ClinVarSet
    def add_ClinVarSet(self, value): self.ClinVarSet.append(value)
    def insert_ClinVarSet_at(self, index, value): self.ClinVarSet.insert(index, value)
    def replace_ClinVarSet_at(self, index, value): self.ClinVarSet[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Dated(self): return self.Dated
    def set_Dated(self, Dated): self.Dated = Dated
    def hasContent_(self):
        if (
            self.ClinVarSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReleaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReleaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReleaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReleaseType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Dated is not None and 'Dated' not in already_processed:
            already_processed.add('Dated')
            outfile.write(' Dated="%s"' % self.gds_format_date(self.Dated, input_name='Dated'))
    def exportChildren(self, outfile, level, namespace_='', name_='ReleaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ClinVarSet_ in self.ClinVarSet:
            ClinVarSet_.export(outfile, level, namespace_, name_='ClinVarSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReleaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Dated is not None and 'Dated' not in already_processed:
            already_processed.add('Dated')
            showIndent(outfile, level)
            outfile.write('Dated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.Dated, input_name='Dated'))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ClinVarSet=[\n')
        level += 1
        for ClinVarSet_ in self.ClinVarSet:
            showIndent(outfile, level)
            outfile.write('model_.ClinVarSet(\n')
            ClinVarSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Dated', node)
        if value is not None and 'Dated' not in already_processed:
            already_processed.add('Dated')
            try:
                self.Dated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (Dated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClinVarSet':
            obj_ = PublicSetType.factory()
            obj_.build(child_)
            self.ClinVarSet.append(obj_)
            obj_.original_tagname_ = 'ClinVarSet'
# end class ReleaseType


class MeasureTraitType(GeneratedsSuper):
    """A modification date is independent of a version change. Content
    generated by NCBI may change without representing a change in
    the version."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, SubmissionName=None, SubmissionDate=None, DateLastUpdated=None, DateCreated=None, ClinVarSubmissionID=None, ClinVarAccession=None, AdditionalSubmitters=None, RecordStatus='current', ClinicalSignificance=None, CustomAssertionScore=None, Assertion=None, ExternalID=None, AttributeSet=None, ObservedIn=None, MeasureSet=None, TraitSet=None, Citation=None, StudyName=None, StudyDescription=None, Comment=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.SubmissionName = _cast(None, SubmissionName)
        if isinstance(SubmissionDate, basestring):
            initvalue_ = datetime_.datetime.strptime(SubmissionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = SubmissionDate
        self.SubmissionDate = initvalue_
        if isinstance(DateLastUpdated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateLastUpdated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastUpdated
        self.DateLastUpdated = initvalue_
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.ClinVarSubmissionID = ClinVarSubmissionID
        self.ClinVarAccession = ClinVarAccession
        self.AdditionalSubmitters = AdditionalSubmitters
        self.RecordStatus = RecordStatus
        self.validate_RecordStatusType1(self.RecordStatus)
        self.ClinicalSignificance = ClinicalSignificance
        if CustomAssertionScore is None:
            self.CustomAssertionScore = []
        else:
            self.CustomAssertionScore = CustomAssertionScore
        self.Assertion = Assertion
        self.ExternalID = ExternalID
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if ObservedIn is None:
            self.ObservedIn = []
        else:
            self.ObservedIn = ObservedIn
        self.MeasureSet = MeasureSet
        self.TraitSet = TraitSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.StudyName = StudyName
        self.StudyDescription = StudyDescription
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if MeasureTraitType.subclass:
            return MeasureTraitType.subclass(*args_, **kwargs_)
        else:
            return MeasureTraitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClinVarSubmissionID(self): return self.ClinVarSubmissionID
    def set_ClinVarSubmissionID(self, ClinVarSubmissionID): self.ClinVarSubmissionID = ClinVarSubmissionID
    def get_ClinVarAccession(self): return self.ClinVarAccession
    def set_ClinVarAccession(self, ClinVarAccession): self.ClinVarAccession = ClinVarAccession
    def get_AdditionalSubmitters(self): return self.AdditionalSubmitters
    def set_AdditionalSubmitters(self, AdditionalSubmitters): self.AdditionalSubmitters = AdditionalSubmitters
    def get_RecordStatus(self): return self.RecordStatus
    def set_RecordStatus(self, RecordStatus): self.RecordStatus = RecordStatus
    def get_ClinicalSignificance(self): return self.ClinicalSignificance
    def set_ClinicalSignificance(self, ClinicalSignificance): self.ClinicalSignificance = ClinicalSignificance
    def get_CustomAssertionScore(self): return self.CustomAssertionScore
    def set_CustomAssertionScore(self, CustomAssertionScore): self.CustomAssertionScore = CustomAssertionScore
    def add_CustomAssertionScore(self, value): self.CustomAssertionScore.append(value)
    def insert_CustomAssertionScore_at(self, index, value): self.CustomAssertionScore.insert(index, value)
    def replace_CustomAssertionScore_at(self, index, value): self.CustomAssertionScore[index] = value
    def get_Assertion(self): return self.Assertion
    def set_Assertion(self, Assertion): self.Assertion = Assertion
    def get_ExternalID(self): return self.ExternalID
    def set_ExternalID(self, ExternalID): self.ExternalID = ExternalID
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_ObservedIn(self): return self.ObservedIn
    def set_ObservedIn(self, ObservedIn): self.ObservedIn = ObservedIn
    def add_ObservedIn(self, value): self.ObservedIn.append(value)
    def insert_ObservedIn_at(self, index, value): self.ObservedIn.insert(index, value)
    def replace_ObservedIn_at(self, index, value): self.ObservedIn[index] = value
    def get_MeasureSet(self): return self.MeasureSet
    def set_MeasureSet(self, MeasureSet): self.MeasureSet = MeasureSet
    def get_TraitSet(self): return self.TraitSet
    def set_TraitSet(self, TraitSet): self.TraitSet = TraitSet
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_StudyName(self): return self.StudyName
    def set_StudyName(self, StudyName): self.StudyName = StudyName
    def get_StudyDescription(self): return self.StudyDescription
    def set_StudyDescription(self, StudyDescription): self.StudyDescription = StudyDescription
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SubmissionName(self): return self.SubmissionName
    def set_SubmissionName(self, SubmissionName): self.SubmissionName = SubmissionName
    def get_SubmissionDate(self): return self.SubmissionDate
    def set_SubmissionDate(self, SubmissionDate): self.SubmissionDate = SubmissionDate
    def get_DateLastUpdated(self): return self.DateLastUpdated
    def set_DateLastUpdated(self, DateLastUpdated): self.DateLastUpdated = DateLastUpdated
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def validate_RecordStatusType1(self, value):
        # Validate type RecordStatusType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['current', 'replaced', 'removed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecordStatusType1' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClinVarSubmissionID is not None or
            self.ClinVarAccession is not None or
            self.AdditionalSubmitters is not None or
            self.RecordStatus is not None or
            self.ClinicalSignificance is not None or
            self.CustomAssertionScore or
            self.Assertion is not None or
            self.ExternalID is not None or
            self.AttributeSet or
            self.ObservedIn or
            self.MeasureSet is not None or
            self.TraitSet is not None or
            self.Citation or
            self.StudyName is not None or
            self.StudyDescription is not None or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeasureTraitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureTraitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeasureTraitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureTraitType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.SubmissionName is not None and 'SubmissionName' not in already_processed:
            already_processed.add('SubmissionName')
            outfile.write(' SubmissionName=%s' % (self.gds_format_string(quote_attrib(self.SubmissionName).encode(ExternalEncoding), input_name='SubmissionName'), ))
        if self.SubmissionDate is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            outfile.write(' SubmissionDate="%s"' % self.gds_format_date(self.SubmissionDate, input_name='SubmissionDate'))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            outfile.write(' DateLastUpdated="%s"' % self.gds_format_date(self.DateLastUpdated, input_name='DateLastUpdated'))
        if self.DateCreated is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            outfile.write(' DateCreated="%s"' % self.gds_format_date(self.DateCreated, input_name='DateCreated'))
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureTraitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClinVarSubmissionID is not None:
            self.ClinVarSubmissionID.export(outfile, level, namespace_, name_='ClinVarSubmissionID', pretty_print=pretty_print)
        if self.ClinVarAccession is not None:
            self.ClinVarAccession.export(outfile, level, namespace_, name_='ClinVarAccession', pretty_print=pretty_print)
        if self.AdditionalSubmitters is not None:
            self.AdditionalSubmitters.export(outfile, level, namespace_, name_='AdditionalSubmitters', pretty_print=pretty_print)
        if self.RecordStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordStatus>%s</%sRecordStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.RecordStatus).encode(ExternalEncoding), input_name='RecordStatus'), namespace_, eol_))
        if self.ClinicalSignificance is not None:
            self.ClinicalSignificance.export(outfile, level, namespace_, name_='ClinicalSignificance', pretty_print=pretty_print)
        for CustomAssertionScore_ in self.CustomAssertionScore:
            CustomAssertionScore_.export(outfile, level, namespace_, name_='CustomAssertionScore', pretty_print=pretty_print)
        if self.Assertion is not None:
            self.Assertion.export(outfile, level, namespace_, name_='Assertion', pretty_print=pretty_print)
        if self.ExternalID is not None:
            self.ExternalID.export(outfile, level, namespace_, name_='ExternalID', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for ObservedIn_ in self.ObservedIn:
            ObservedIn_.export(outfile, level, namespace_, name_='ObservedIn', pretty_print=pretty_print)
        if self.MeasureSet is not None:
            self.MeasureSet.export(outfile, level, namespace_, name_='MeasureSet', pretty_print=pretty_print)
        if self.TraitSet is not None:
            self.TraitSet.export(outfile, level, namespace_, name_='TraitSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        if self.StudyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStudyName>%s</%sStudyName>%s' % (namespace_, self.gds_format_string(quote_xml(self.StudyName).encode(ExternalEncoding), input_name='StudyName'), namespace_, eol_))
        if self.StudyDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStudyDescription>%s</%sStudyDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.StudyDescription).encode(ExternalEncoding), input_name='StudyDescription'), namespace_, eol_))
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeasureTraitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
        if self.SubmissionName is not None and 'SubmissionName' not in already_processed:
            already_processed.add('SubmissionName')
            showIndent(outfile, level)
            outfile.write('SubmissionName="%s",\n' % (self.SubmissionName,))
        if self.SubmissionDate is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            showIndent(outfile, level)
            outfile.write('SubmissionDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.SubmissionDate, input_name='SubmissionDate'))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            showIndent(outfile, level)
            outfile.write('DateLastUpdated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateLastUpdated, input_name='DateLastUpdated'))
        if self.DateCreated is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateCreated, input_name='DateCreated'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ClinVarSubmissionID is not None:
            showIndent(outfile, level)
            outfile.write('ClinVarSubmissionID=model_.ClinVarSubmissionIDType(\n')
            self.ClinVarSubmissionID.exportLiteral(outfile, level, name_='ClinVarSubmissionID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ClinVarAccession is not None:
            showIndent(outfile, level)
            outfile.write('ClinVarAccession=model_.ClinVarAccessionType(\n')
            self.ClinVarAccession.exportLiteral(outfile, level, name_='ClinVarAccession')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AdditionalSubmitters is not None:
            showIndent(outfile, level)
            outfile.write('AdditionalSubmitters=model_.AdditionalSubmittersType(\n')
            self.AdditionalSubmitters.exportLiteral(outfile, level, name_='AdditionalSubmitters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RecordStatus is not None:
            showIndent(outfile, level)
            outfile.write('RecordStatus=%s,\n' % quote_python(self.RecordStatus).encode(ExternalEncoding))
        if self.ClinicalSignificance is not None:
            showIndent(outfile, level)
            outfile.write('ClinicalSignificance=model_.ClinicalSignificanceTypeSCV(\n')
            self.ClinicalSignificance.exportLiteral(outfile, level, name_='ClinicalSignificance')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CustomAssertionScore=[\n')
        level += 1
        for CustomAssertionScore_ in self.CustomAssertionScore:
            showIndent(outfile, level)
            outfile.write('model_.CustomAssertionScoreType(\n')
            CustomAssertionScore_.exportLiteral(outfile, level, name_='CustomAssertionScoreType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Assertion is not None:
            showIndent(outfile, level)
            outfile.write('Assertion=model_.AssertionTypeSCV(\n')
            self.Assertion.exportLiteral(outfile, level, name_='Assertion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalID is not None:
            showIndent(outfile, level)
            outfile.write('ExternalID=model_.XrefType(\n')
            self.ExternalID.exportLiteral(outfile, level, name_='ExternalID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ObservedIn=[\n')
        level += 1
        for ObservedIn_ in self.ObservedIn:
            showIndent(outfile, level)
            outfile.write('model_.ObservationSet(\n')
            ObservedIn_.exportLiteral(outfile, level, name_='ObservationSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MeasureSet is not None:
            showIndent(outfile, level)
            outfile.write('MeasureSet=model_.MeasureSetType(\n')
            self.MeasureSet.exportLiteral(outfile, level, name_='MeasureSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TraitSet is not None:
            showIndent(outfile, level)
            outfile.write('TraitSet=model_.TraitSetType(\n')
            self.TraitSet.exportLiteral(outfile, level, name_='TraitSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StudyName is not None:
            showIndent(outfile, level)
            outfile.write('StudyName=%s,\n' % quote_python(self.StudyName).encode(ExternalEncoding))
        if self.StudyDescription is not None:
            showIndent(outfile, level)
            outfile.write('StudyDescription=%s,\n' % quote_python(self.StudyDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('SubmissionName', node)
        if value is not None and 'SubmissionName' not in already_processed:
            already_processed.add('SubmissionName')
            self.SubmissionName = value
        value = find_attr_value_('SubmissionDate', node)
        if value is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            try:
                self.SubmissionDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (SubmissionDate): %s' % exp)
        value = find_attr_value_('DateLastUpdated', node)
        if value is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            try:
                self.DateLastUpdated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateLastUpdated): %s' % exp)
        value = find_attr_value_('DateCreated', node)
        if value is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            try:
                self.DateCreated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateCreated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClinVarSubmissionID':
            obj_ = ClinVarSubmissionIDType.factory()
            obj_.build(child_)
            self.ClinVarSubmissionID = obj_
            obj_.original_tagname_ = 'ClinVarSubmissionID'
        elif nodeName_ == 'ClinVarAccession':
            obj_ = ClinVarAccessionType.factory()
            obj_.build(child_)
            self.ClinVarAccession = obj_
            obj_.original_tagname_ = 'ClinVarAccession'
        elif nodeName_ == 'AdditionalSubmitters':
            obj_ = AdditionalSubmittersType.factory()
            obj_.build(child_)
            self.AdditionalSubmitters = obj_
            obj_.original_tagname_ = 'AdditionalSubmitters'
        elif nodeName_ == 'RecordStatus':
            RecordStatus_ = child_.text
            RecordStatus_ = self.gds_validate_string(RecordStatus_, node, 'RecordStatus')
            self.RecordStatus = RecordStatus_
            self.validate_RecordStatusType1(self.RecordStatus)    # validate type RecordStatusType1
        elif nodeName_ == 'ClinicalSignificance':
            obj_ = ClinicalSignificanceTypeSCV.factory()
            obj_.build(child_)
            self.ClinicalSignificance = obj_
            obj_.original_tagname_ = 'ClinicalSignificance'
        elif nodeName_ == 'CustomAssertionScore':
            obj_ = CustomAssertionScoreType.factory()
            obj_.build(child_)
            self.CustomAssertionScore.append(obj_)
            obj_.original_tagname_ = 'CustomAssertionScore'
        elif nodeName_ == 'Assertion':
            obj_ = AssertionTypeSCV.factory()
            obj_.build(child_)
            self.Assertion = obj_
            obj_.original_tagname_ = 'Assertion'
        elif nodeName_ == 'ExternalID':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.ExternalID = obj_
            obj_.original_tagname_ = 'ExternalID'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'ObservedIn':
            obj_ = ObservationSet.factory()
            obj_.build(child_)
            self.ObservedIn.append(obj_)
            obj_.original_tagname_ = 'ObservedIn'
        elif nodeName_ == 'MeasureSet':
            obj_ = MeasureSetType.factory()
            obj_.build(child_)
            self.MeasureSet = obj_
            obj_.original_tagname_ = 'MeasureSet'
        elif nodeName_ == 'TraitSet':
            obj_ = TraitSetType.factory()
            obj_.build(child_)
            self.TraitSet = obj_
            obj_.original_tagname_ = 'TraitSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'StudyName':
            StudyName_ = child_.text
            StudyName_ = self.gds_validate_string(StudyName_, node, 'StudyName')
            self.StudyName = StudyName_
        elif nodeName_ == 'StudyDescription':
            StudyDescription_ = child_.text
            StudyDescription_ = self.gds_validate_string(StudyDescription_, node, 'StudyDescription')
            self.StudyDescription = StudyDescription_
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class MeasureTraitType


class ReferenceAssertionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, SubmissionDate=None, DateLastUpdated=None, DateCreated=None, ClinVarAccession=None, RecordStatus='current', ClinicalSignificance=None, Assertion=None, ExternalID=None, AttributeSet=None, ObservedIn=None, MeasureSet=None, TraitSet=None, Citation=None, Comment=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        if isinstance(SubmissionDate, basestring):
            initvalue_ = datetime_.datetime.strptime(SubmissionDate, '%Y-%m-%d').date()
        else:
            initvalue_ = SubmissionDate
        self.SubmissionDate = initvalue_
        if isinstance(DateLastUpdated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateLastUpdated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastUpdated
        self.DateLastUpdated = initvalue_
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.ClinVarAccession = ClinVarAccession
        self.RecordStatus = RecordStatus
        self.validate_RecordStatusType4(self.RecordStatus)
        self.ClinicalSignificance = ClinicalSignificance
        self.Assertion = Assertion
        self.ExternalID = ExternalID
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if ObservedIn is None:
            self.ObservedIn = []
        else:
            self.ObservedIn = ObservedIn
        self.MeasureSet = MeasureSet
        self.TraitSet = TraitSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ReferenceAssertionType.subclass:
            return ReferenceAssertionType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssertionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClinVarAccession(self): return self.ClinVarAccession
    def set_ClinVarAccession(self, ClinVarAccession): self.ClinVarAccession = ClinVarAccession
    def get_RecordStatus(self): return self.RecordStatus
    def set_RecordStatus(self, RecordStatus): self.RecordStatus = RecordStatus
    def get_ClinicalSignificance(self): return self.ClinicalSignificance
    def set_ClinicalSignificance(self, ClinicalSignificance): self.ClinicalSignificance = ClinicalSignificance
    def get_Assertion(self): return self.Assertion
    def set_Assertion(self, Assertion): self.Assertion = Assertion
    def get_ExternalID(self): return self.ExternalID
    def set_ExternalID(self, ExternalID): self.ExternalID = ExternalID
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_ObservedIn(self): return self.ObservedIn
    def set_ObservedIn(self, ObservedIn): self.ObservedIn = ObservedIn
    def add_ObservedIn(self, value): self.ObservedIn.append(value)
    def insert_ObservedIn_at(self, index, value): self.ObservedIn.insert(index, value)
    def replace_ObservedIn_at(self, index, value): self.ObservedIn[index] = value
    def get_MeasureSet(self): return self.MeasureSet
    def set_MeasureSet(self, MeasureSet): self.MeasureSet = MeasureSet
    def get_TraitSet(self): return self.TraitSet
    def set_TraitSet(self, TraitSet): self.TraitSet = TraitSet
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SubmissionDate(self): return self.SubmissionDate
    def set_SubmissionDate(self, SubmissionDate): self.SubmissionDate = SubmissionDate
    def get_DateLastUpdated(self): return self.DateLastUpdated
    def set_DateLastUpdated(self, DateLastUpdated): self.DateLastUpdated = DateLastUpdated
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def validate_RecordStatusType4(self, value):
        # Validate type RecordStatusType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['current', 'replaced', 'removed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecordStatusType4' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ClinVarAccession is not None or
            self.RecordStatus is not None or
            self.ClinicalSignificance is not None or
            self.Assertion is not None or
            self.ExternalID is not None or
            self.AttributeSet or
            self.ObservedIn or
            self.MeasureSet is not None or
            self.TraitSet is not None or
            self.Citation or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAssertionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAssertionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAssertionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAssertionType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.SubmissionDate is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            outfile.write(' SubmissionDate="%s"' % self.gds_format_date(self.SubmissionDate, input_name='SubmissionDate'))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            outfile.write(' DateLastUpdated="%s"' % self.gds_format_date(self.DateLastUpdated, input_name='DateLastUpdated'))
        if self.DateCreated is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            outfile.write(' DateCreated="%s"' % self.gds_format_date(self.DateCreated, input_name='DateCreated'))
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAssertionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClinVarAccession is not None:
            self.ClinVarAccession.export(outfile, level, namespace_, name_='ClinVarAccession', pretty_print=pretty_print)
        if self.RecordStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordStatus>%s</%sRecordStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.RecordStatus).encode(ExternalEncoding), input_name='RecordStatus'), namespace_, eol_))
        if self.ClinicalSignificance is not None:
            self.ClinicalSignificance.export(outfile, level, namespace_, name_='ClinicalSignificance', pretty_print=pretty_print)
        if self.Assertion is not None:
            self.Assertion.export(outfile, level, namespace_, name_='Assertion', pretty_print=pretty_print)
        if self.ExternalID is not None:
            self.ExternalID.export(outfile, level, namespace_, name_='ExternalID', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for ObservedIn_ in self.ObservedIn:
            ObservedIn_.export(outfile, level, namespace_, name_='ObservedIn', pretty_print=pretty_print)
        if self.MeasureSet is not None:
            self.MeasureSet.export(outfile, level, namespace_, name_='MeasureSet', pretty_print=pretty_print)
        if self.TraitSet is not None:
            self.TraitSet.export(outfile, level, namespace_, name_='TraitSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceAssertionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
        if self.SubmissionDate is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            showIndent(outfile, level)
            outfile.write('SubmissionDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.SubmissionDate, input_name='SubmissionDate'))
        if self.DateLastUpdated is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            showIndent(outfile, level)
            outfile.write('DateLastUpdated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateLastUpdated, input_name='DateLastUpdated'))
        if self.DateCreated is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateCreated, input_name='DateCreated'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ClinVarAccession is not None:
            showIndent(outfile, level)
            outfile.write('ClinVarAccession=model_.ClinVarAccessionType3(\n')
            self.ClinVarAccession.exportLiteral(outfile, level, name_='ClinVarAccession')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RecordStatus is not None:
            showIndent(outfile, level)
            outfile.write('RecordStatus=%s,\n' % quote_python(self.RecordStatus).encode(ExternalEncoding))
        if self.ClinicalSignificance is not None:
            showIndent(outfile, level)
            outfile.write('ClinicalSignificance=model_.ClinicalSignificanceType(\n')
            self.ClinicalSignificance.exportLiteral(outfile, level, name_='ClinicalSignificance')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Assertion is not None:
            showIndent(outfile, level)
            outfile.write('Assertion=model_.AssertionTypeRCV(\n')
            self.Assertion.exportLiteral(outfile, level, name_='Assertion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalID is not None:
            showIndent(outfile, level)
            outfile.write('ExternalID=model_.XrefType(\n')
            self.ExternalID.exportLiteral(outfile, level, name_='ExternalID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType5(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ObservedIn=[\n')
        level += 1
        for ObservedIn_ in self.ObservedIn:
            showIndent(outfile, level)
            outfile.write('model_.ObservationSet(\n')
            ObservedIn_.exportLiteral(outfile, level, name_='ObservationSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MeasureSet is not None:
            showIndent(outfile, level)
            outfile.write('MeasureSet=model_.MeasureSetType(\n')
            self.MeasureSet.exportLiteral(outfile, level, name_='MeasureSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TraitSet is not None:
            showIndent(outfile, level)
            outfile.write('TraitSet=model_.TraitSetType(\n')
            self.TraitSet.exportLiteral(outfile, level, name_='TraitSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('SubmissionDate', node)
        if value is not None and 'SubmissionDate' not in already_processed:
            already_processed.add('SubmissionDate')
            try:
                self.SubmissionDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (SubmissionDate): %s' % exp)
        value = find_attr_value_('DateLastUpdated', node)
        if value is not None and 'DateLastUpdated' not in already_processed:
            already_processed.add('DateLastUpdated')
            try:
                self.DateLastUpdated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateLastUpdated): %s' % exp)
        value = find_attr_value_('DateCreated', node)
        if value is not None and 'DateCreated' not in already_processed:
            already_processed.add('DateCreated')
            try:
                self.DateCreated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateCreated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClinVarAccession':
            obj_ = ClinVarAccessionType3.factory()
            obj_.build(child_)
            self.ClinVarAccession = obj_
            obj_.original_tagname_ = 'ClinVarAccession'
        elif nodeName_ == 'RecordStatus':
            RecordStatus_ = child_.text
            RecordStatus_ = self.gds_validate_string(RecordStatus_, node, 'RecordStatus')
            self.RecordStatus = RecordStatus_
            self.validate_RecordStatusType4(self.RecordStatus)    # validate type RecordStatusType4
        elif nodeName_ == 'ClinicalSignificance':
            obj_ = ClinicalSignificanceType.factory()
            obj_.build(child_)
            self.ClinicalSignificance = obj_
            obj_.original_tagname_ = 'ClinicalSignificance'
        elif nodeName_ == 'Assertion':
            obj_ = AssertionTypeRCV.factory()
            obj_.build(child_)
            self.Assertion = obj_
            obj_.original_tagname_ = 'Assertion'
        elif nodeName_ == 'ExternalID':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.ExternalID = obj_
            obj_.original_tagname_ = 'ExternalID'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType5.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'ObservedIn':
            obj_ = ObservationSet.factory()
            obj_.build(child_)
            self.ObservedIn.append(obj_)
            obj_.original_tagname_ = 'ObservedIn'
        elif nodeName_ == 'MeasureSet':
            obj_ = MeasureSetType.factory()
            obj_.build(child_)
            self.MeasureSet = obj_
            obj_.original_tagname_ = 'MeasureSet'
        elif nodeName_ == 'TraitSet':
            obj_ = TraitSetType.factory()
            obj_.build(child_)
            self.TraitSet = obj_
            obj_.original_tagname_ = 'TraitSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ReferenceAssertionType


class MeasureSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Measure=None, Name=None, Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Measure is None:
            self.Measure = []
        else:
            self.Measure = Measure
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if MeasureSetType.subclass:
            return MeasureSetType.subclass(*args_, **kwargs_)
        else:
            return MeasureSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Measure(self): return self.Measure
    def set_Measure(self, Measure): self.Measure = Measure
    def add_Measure(self, value): self.Measure.append(value)
    def insert_Measure_at(self, index, value): self.Measure.insert(index, value)
    def replace_Measure_at(self, index, value): self.Measure[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Measure or
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeasureSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeasureSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureSetType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Measure_ in self.Measure:
            Measure_.export(outfile, level, namespace_, name_='Measure', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeasureSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Measure=[\n')
        level += 1
        for Measure_ in self.Measure:
            showIndent(outfile, level)
            outfile.write('model_.MeasureType(\n')
            Measure_.exportLiteral(outfile, level, name_='MeasureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType11(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType11')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Measure':
            obj_ = MeasureType.factory()
            obj_.build(child_)
            self.Measure.append(obj_)
            obj_.original_tagname_ = 'Measure'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType11.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class MeasureSetType


class TraitSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Trait=None, Name=None, Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Trait is None:
            self.Trait = []
        else:
            self.Trait = Trait
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if TraitSetType.subclass:
            return TraitSetType.subclass(*args_, **kwargs_)
        else:
            return TraitSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trait(self): return self.Trait
    def set_Trait(self, Trait): self.Trait = Trait
    def add_Trait(self, value): self.Trait.append(value)
    def insert_Trait_at(self, index, value): self.Trait.insert(index, value)
    def replace_Trait_at(self, index, value): self.Trait[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Trait or
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TraitSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TraitSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TraitSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TraitSetType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='TraitSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Trait_ in self.Trait:
            Trait_.export(outfile, level, namespace_, name_='Trait', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TraitSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Trait=[\n')
        level += 1
        for Trait_ in self.Trait:
            showIndent(outfile, level)
            outfile.write('model_.TraitType(\n')
            Trait_.exportLiteral(outfile, level, name_='TraitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType13(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType13')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trait':
            obj_ = TraitType.factory()
            obj_.build(child_)
            self.Trait.append(obj_)
            obj_.original_tagname_ = 'Trait'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType13.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class TraitSetType


class TraitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Name=None, Symbol=None, AttributeSet=None, TraitRelationship=None, Citation=None, XRef=None, Comment=None, Source=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if TraitRelationship is None:
            self.TraitRelationship = []
        else:
            self.TraitRelationship = TraitRelationship
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
    def factory(*args_, **kwargs_):
        if TraitType.subclass:
            return TraitType.subclass(*args_, **kwargs_)
        else:
            return TraitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_TraitRelationship(self): return self.TraitRelationship
    def set_TraitRelationship(self, TraitRelationship): self.TraitRelationship = TraitRelationship
    def add_TraitRelationship(self, value): self.TraitRelationship.append(value)
    def insert_TraitRelationship_at(self, index, value): self.TraitRelationship.insert(index, value)
    def replace_TraitRelationship_at(self, index, value): self.TraitRelationship[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source_at(self, index, value): self.Source.insert(index, value)
    def replace_Source_at(self, index, value): self.Source[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.TraitRelationship or
            self.Citation or
            self.XRef or
            self.Comment or
            self.Source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TraitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TraitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TraitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TraitType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='TraitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for TraitRelationship_ in self.TraitRelationship:
            TraitRelationship_.export(outfile, level, namespace_, name_='TraitRelationship', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for Source_ in self.Source:
            Source_.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TraitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType15(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType15')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TraitRelationship=[\n')
        level += 1
        for TraitRelationship_ in self.TraitRelationship:
            showIndent(outfile, level)
            outfile.write('model_.TraitRelationshipType(\n')
            TraitRelationship_.exportLiteral(outfile, level, name_='TraitRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('model_.DataSourceType(\n')
            Source_.exportLiteral(outfile, level, name_='DataSourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType15.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'TraitRelationship':
            obj_ = TraitRelationshipType.factory()
            obj_.build(child_)
            self.TraitRelationship.append(obj_)
            obj_.original_tagname_ = 'TraitRelationship'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Source':
            obj_ = DataSourceType.factory()
            obj_.build(child_)
            self.Source.append(obj_)
            obj_.original_tagname_ = 'Source'
# end class TraitType


class AttributeType(GeneratedsSuper):
    """The attribute is a general element to represent a defined set of
    data qualified by an enumerated set of types. For each attribute
    element, the value will be a character string and is optional.
    Source shall be used to store identifiers for supplied data from
    source other than the submitter (e.g. SequenceOntology). The
    data submitted where Type="variation" shall be validated against
    sequence_alternation in Sequence Ontology
    http://www.sequenceontology.org/. This is to be a generic
    version of AttributeType and should be used with extension when
    it is used to specify Type and its enumerations."""
    subclass = None
    superclass = None
    def __init__(self, integerValue=None, dateValue=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.integerValue = _cast(int, integerValue)
        if isinstance(dateValue, basestring):
            initvalue_ = datetime_.datetime.strptime(dateValue, '%Y-%m-%d').date()
        else:
            initvalue_ = dateValue
        self.dateValue = initvalue_
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_integerValue(self): return self.integerValue
    def set_integerValue(self, integerValue): self.integerValue = integerValue
    def get_dateValue(self): return self.dateValue
    def set_dateValue(self, dateValue): self.dateValue = dateValue
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType'):
        if self.integerValue is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            outfile.write(' integerValue="%s"' % self.gds_format_integer(self.integerValue, input_name='integerValue'))
        if self.dateValue is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            outfile.write(' dateValue="%s"' % self.gds_format_date(self.dateValue, input_name='dateValue'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.integerValue is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            showIndent(outfile, level)
            outfile.write('integerValue=%d,\n' % (self.integerValue,))
        if self.dateValue is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            showIndent(outfile, level)
            outfile.write('dateValue=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.dateValue, input_name='dateValue'))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integerValue', node)
        if value is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            try:
                self.integerValue = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dateValue', node)
        if value is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            try:
                self.dateValue = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (dateValue): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType


class SetElementSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ElementValue=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.ElementValue = ElementValue
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if SetElementSetType.subclass:
            return SetElementSetType.subclass(*args_, **kwargs_)
        else:
            return SetElementSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ElementValue(self): return self.ElementValue
    def set_ElementValue(self, ElementValue): self.ElementValue = ElementValue
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.ElementValue is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SetElementSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetElementSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SetElementSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SetElementSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SetElementSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ElementValue is not None:
            self.ElementValue.export(outfile, level, namespace_, name_='ElementValue', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SetElementSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ElementValue is not None:
            showIndent(outfile, level)
            outfile.write('ElementValue=model_.ElementValueType(\n')
            self.ElementValue.exportLiteral(outfile, level, name_='ElementValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ElementValue':
            obj_ = ElementValueType.factory()
            obj_.build(child_)
            self.ElementValue = obj_
            obj_.original_tagname_ = 'ElementValue'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class SetElementSetType


class SoftwareSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, name=None, purpose=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.name = _cast(None, name)
        self.purpose = _cast(None, purpose)
    def factory(*args_, **kwargs_):
        if SoftwareSet.subclass:
            return SoftwareSet.subclass(*args_, **kwargs_)
        else:
            return SoftwareSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_purpose(self): return self.purpose
    def set_purpose(self, purpose): self.purpose = purpose
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SoftwareSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SoftwareSet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SoftwareSet'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_format_string(quote_attrib(self.purpose).encode(ExternalEncoding), input_name='purpose'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SoftwareSet', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SoftwareSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            showIndent(outfile, level)
            outfile.write('purpose="%s",\n' % (self.purpose,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SoftwareSet


class SubmitterType(GeneratedsSuper):
    """A structure to support reportng the name of a submitter, its org_id,
    and whether primary or not"""
    subclass = None
    superclass = None
    def __init__(self, category=None, OrgID=None, SubmitterName=None, primary=None, valueOf_=None):
        self.original_tagname_ = None
        self.category = _cast(None, category)
        self.OrgID = _cast(int, OrgID)
        self.SubmitterName = _cast(None, SubmitterName)
        self.primary = _cast(None, primary)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SubmitterType.subclass:
            return SubmitterType.subclass(*args_, **kwargs_)
        else:
            return SubmitterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_OrgID(self): return self.OrgID
    def set_OrgID(self, OrgID): self.OrgID = OrgID
    def get_SubmitterName(self): return self.SubmitterName
    def set_SubmitterName(self, SubmitterName): self.SubmitterName = SubmitterName
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubmitterType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubmitterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubmitterType'):
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.OrgID is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            outfile.write(' OrgID="%s"' % self.gds_format_integer(self.OrgID, input_name='OrgID'))
        if self.SubmitterName is not None and 'SubmitterName' not in already_processed:
            already_processed.add('SubmitterName')
            outfile.write(' SubmitterName=%s' % (self.gds_format_string(quote_attrib(self.SubmitterName).encode(ExternalEncoding), input_name='SubmitterName'), ))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary=%s' % (self.gds_format_string(quote_attrib(self.primary).encode(ExternalEncoding), input_name='primary'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubmitterType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SubmitterType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category="%s",\n' % (self.category,))
        if self.OrgID is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            showIndent(outfile, level)
            outfile.write('OrgID=%d,\n' % (self.OrgID,))
        if self.SubmitterName is not None and 'SubmitterName' not in already_processed:
            already_processed.add('SubmitterName')
            showIndent(outfile, level)
            outfile.write('SubmitterName="%s",\n' % (self.SubmitterName,))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            showIndent(outfile, level)
            outfile.write('primary="%s",\n' % (self.primary,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('OrgID', node)
        if value is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            try:
                self.OrgID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('SubmitterName', node)
        if value is not None and 'SubmitterName' not in already_processed:
            already_processed.add('SubmitterName')
            self.SubmitterName = value
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            self.primary = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubmitterType


class MethodType(GeneratedsSuper):
    """Details of a method used to generate variant calls or predict/report
    functional consequence. The name of the platform should
    represent a sequencer or an array, e.g. sequencing or array ,
    e.g. capillary, 454, Helicos, Solexa, SOLiD. This structure
    should also be used if the method is 'Curation'."""
    subclass = None
    superclass = None
    def __init__(self, NamePlatform=None, TypePlatform=None, Purpose=None, ResultType=None, MinReported=None, MaxReported=None, ReferenceStandard=None, Citation=None, XRef=None, Description=None, Software=None, SourceType=None, MethodType_member=None, MethodAttribute=None, MethodResult=None, extensiontype_=None):
        self.original_tagname_ = None
        self.NamePlatform = NamePlatform
        self.TypePlatform = TypePlatform
        self.Purpose = Purpose
        self.ResultType = ResultType
        self.validate_ResultTypeType(self.ResultType)
        self.MinReported = MinReported
        self.MaxReported = MaxReported
        self.ReferenceStandard = ReferenceStandard
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.Description = Description
        if Software is None:
            self.Software = []
        else:
            self.Software = Software
        self.SourceType = SourceType
        self.validate_SourceTypeType(self.SourceType)
        self.MethodType = MethodType_member
        self.validate_Methodtypelist(self.MethodType)
        if MethodAttribute is None:
            self.MethodAttribute = []
        else:
            self.MethodAttribute = MethodAttribute
        if MethodResult is None:
            self.MethodResult = []
        else:
            self.MethodResult = MethodResult
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MethodType.subclass:
            return MethodType.subclass(*args_, **kwargs_)
        else:
            return MethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NamePlatform(self): return self.NamePlatform
    def set_NamePlatform(self, NamePlatform): self.NamePlatform = NamePlatform
    def get_TypePlatform(self): return self.TypePlatform
    def set_TypePlatform(self, TypePlatform): self.TypePlatform = TypePlatform
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_ResultType(self): return self.ResultType
    def set_ResultType(self, ResultType): self.ResultType = ResultType
    def get_MinReported(self): return self.MinReported
    def set_MinReported(self, MinReported): self.MinReported = MinReported
    def get_MaxReported(self): return self.MaxReported
    def set_MaxReported(self, MaxReported): self.MaxReported = MaxReported
    def get_ReferenceStandard(self): return self.ReferenceStandard
    def set_ReferenceStandard(self, ReferenceStandard): self.ReferenceStandard = ReferenceStandard
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Software(self): return self.Software
    def set_Software(self, Software): self.Software = Software
    def add_Software(self, value): self.Software.append(value)
    def insert_Software_at(self, index, value): self.Software.insert(index, value)
    def replace_Software_at(self, index, value): self.Software[index] = value
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_MethodType(self): return self.MethodType
    def set_MethodType(self, MethodType): self.MethodType = MethodType
    def get_MethodAttribute(self): return self.MethodAttribute
    def set_MethodAttribute(self, MethodAttribute): self.MethodAttribute = MethodAttribute
    def add_MethodAttribute(self, value): self.MethodAttribute.append(value)
    def insert_MethodAttribute_at(self, index, value): self.MethodAttribute.insert(index, value)
    def replace_MethodAttribute_at(self, index, value): self.MethodAttribute[index] = value
    def get_MethodResult(self): return self.MethodResult
    def set_MethodResult(self, MethodResult): self.MethodResult = MethodResult
    def add_MethodResult(self, value): self.MethodResult.append(value)
    def insert_MethodResult_at(self, index, value): self.MethodResult.insert(index, value)
    def replace_MethodResult_at(self, index, value): self.MethodResult[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ResultTypeType(self, value):
        # Validate type ResultTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['number of occurrences', 'p value', 'odds ratio', 'variation call']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ResultTypeType' % {"value" : value.encode("utf-8")} )
    def validate_SourceTypeType(self, value):
        # Validate type SourceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['submitter-generated', 'data mining', 'data review']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SourceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_Methodtypelist(self, value):
        # Validate type Methodtypelist, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['literature only', 'reference population', 'case-control', 'clinical testing', 'in vitro', 'in vivo', 'research', 'curation', 'not provided']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Methodtypelist' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NamePlatform is not None or
            self.TypePlatform is not None or
            self.Purpose is not None or
            self.ResultType is not None or
            self.MinReported is not None or
            self.MaxReported is not None or
            self.ReferenceStandard is not None or
            self.Citation or
            self.XRef or
            self.Description is not None or
            self.Software or
            self.SourceType is not None or
            self.MethodType is not None or
            self.MethodAttribute or
            self.MethodResult
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MethodType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NamePlatform is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNamePlatform>%s</%sNamePlatform>%s' % (namespace_, self.gds_format_string(quote_xml(self.NamePlatform).encode(ExternalEncoding), input_name='NamePlatform'), namespace_, eol_))
        if self.TypePlatform is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypePlatform>%s</%sTypePlatform>%s' % (namespace_, self.gds_format_string(quote_xml(self.TypePlatform).encode(ExternalEncoding), input_name='TypePlatform'), namespace_, eol_))
        if self.Purpose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurpose>%s</%sPurpose>%s' % (namespace_, self.gds_format_string(quote_xml(self.Purpose).encode(ExternalEncoding), input_name='Purpose'), namespace_, eol_))
        if self.ResultType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResultType>%s</%sResultType>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResultType).encode(ExternalEncoding), input_name='ResultType'), namespace_, eol_))
        if self.MinReported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinReported>%s</%sMinReported>%s' % (namespace_, self.gds_format_string(quote_xml(self.MinReported).encode(ExternalEncoding), input_name='MinReported'), namespace_, eol_))
        if self.MaxReported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxReported>%s</%sMaxReported>%s' % (namespace_, self.gds_format_string(quote_xml(self.MaxReported).encode(ExternalEncoding), input_name='MaxReported'), namespace_, eol_))
        if self.ReferenceStandard is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceStandard>%s</%sReferenceStandard>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReferenceStandard).encode(ExternalEncoding), input_name='ReferenceStandard'), namespace_, eol_))
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        for Software_ in self.Software:
            Software_.export(outfile, level, namespace_, name_='Software', pretty_print=pretty_print)
        if self.SourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceType>%s</%sSourceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), namespace_, eol_))
        if self.MethodType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethodType>%s</%sMethodType>%s' % (namespace_, self.gds_format_string(quote_xml(self.MethodType).encode(ExternalEncoding), input_name='MethodType'), namespace_, eol_))
        for MethodAttribute_ in self.MethodAttribute:
            MethodAttribute_.export(outfile, level, namespace_, name_='MethodAttribute', pretty_print=pretty_print)
        for MethodResult_ in self.MethodResult:
            MethodResult_.export(outfile, level, namespace_, name_='MethodResult', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NamePlatform is not None:
            showIndent(outfile, level)
            outfile.write('NamePlatform=%s,\n' % quote_python(self.NamePlatform).encode(ExternalEncoding))
        if self.TypePlatform is not None:
            showIndent(outfile, level)
            outfile.write('TypePlatform=%s,\n' % quote_python(self.TypePlatform).encode(ExternalEncoding))
        if self.Purpose is not None:
            showIndent(outfile, level)
            outfile.write('Purpose=%s,\n' % quote_python(self.Purpose).encode(ExternalEncoding))
        if self.ResultType is not None:
            showIndent(outfile, level)
            outfile.write('ResultType=%s,\n' % quote_python(self.ResultType).encode(ExternalEncoding))
        if self.MinReported is not None:
            showIndent(outfile, level)
            outfile.write('MinReported=%s,\n' % quote_python(self.MinReported).encode(ExternalEncoding))
        if self.MaxReported is not None:
            showIndent(outfile, level)
            outfile.write('MaxReported=%s,\n' % quote_python(self.MaxReported).encode(ExternalEncoding))
        if self.ReferenceStandard is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceStandard=%s,\n' % quote_python(self.ReferenceStandard).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Software=[\n')
        level += 1
        for Software_ in self.Software:
            showIndent(outfile, level)
            outfile.write('model_.SoftwareSet(\n')
            Software_.exportLiteral(outfile, level, name_='SoftwareSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SourceType is not None:
            showIndent(outfile, level)
            outfile.write('SourceType=%s,\n' % quote_python(self.SourceType).encode(ExternalEncoding))
        if self.MethodType is not None:
            showIndent(outfile, level)
            outfile.write('MethodType=%s,\n' % quote_python(self.MethodType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('MethodAttribute=[\n')
        level += 1
        for MethodAttribute_ in self.MethodAttribute:
            showIndent(outfile, level)
            outfile.write('model_.MethodAttributeType(\n')
            MethodAttribute_.exportLiteral(outfile, level, name_='MethodAttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MethodResult=[\n')
        level += 1
        for MethodResult_ in self.MethodResult:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            MethodResult_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NamePlatform':
            NamePlatform_ = child_.text
            NamePlatform_ = self.gds_validate_string(NamePlatform_, node, 'NamePlatform')
            self.NamePlatform = NamePlatform_
        elif nodeName_ == 'TypePlatform':
            TypePlatform_ = child_.text
            TypePlatform_ = self.gds_validate_string(TypePlatform_, node, 'TypePlatform')
            self.TypePlatform = TypePlatform_
        elif nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
        elif nodeName_ == 'ResultType':
            ResultType_ = child_.text
            ResultType_ = self.gds_validate_string(ResultType_, node, 'ResultType')
            self.ResultType = ResultType_
            self.validate_ResultTypeType(self.ResultType)    # validate type ResultTypeType
        elif nodeName_ == 'MinReported':
            MinReported_ = child_.text
            MinReported_ = self.gds_validate_string(MinReported_, node, 'MinReported')
            self.MinReported = MinReported_
        elif nodeName_ == 'MaxReported':
            MaxReported_ = child_.text
            MaxReported_ = self.gds_validate_string(MaxReported_, node, 'MaxReported')
            self.MaxReported = MaxReported_
        elif nodeName_ == 'ReferenceStandard':
            ReferenceStandard_ = child_.text
            ReferenceStandard_ = self.gds_validate_string(ReferenceStandard_, node, 'ReferenceStandard')
            self.ReferenceStandard = ReferenceStandard_
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Software':
            obj_ = SoftwareSet.factory()
            obj_.build(child_)
            self.Software.append(obj_)
            obj_.original_tagname_ = 'Software'
        elif nodeName_ == 'SourceType':
            SourceType_ = child_.text
            SourceType_ = self.gds_validate_string(SourceType_, node, 'SourceType')
            self.SourceType = SourceType_
            self.validate_SourceTypeType(self.SourceType)    # validate type SourceTypeType
        elif nodeName_ == 'MethodType':
            MethodType_ = child_.text
            MethodType_ = self.gds_validate_string(MethodType_, node, 'MethodType')
            self.MethodType = MethodType_
            self.validate_Methodtypelist(self.MethodType)    # validate type Methodtypelist
        elif nodeName_ == 'MethodAttribute':
            obj_ = MethodAttributeType.factory()
            obj_.build(child_)
            self.MethodAttribute.append(obj_)
            obj_.original_tagname_ = 'MethodAttribute'
        elif nodeName_ == 'MethodResult':
            class_obj_ = self.get_class_obj_(child_, AttributeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.MethodResult.append(obj_)
            obj_.original_tagname_ = 'MethodResult'
# end class MethodType


class ObservationSet(GeneratedsSuper):
    """Documents in what populations or samples an allele or genotype has
    been observed relative to the described trait. Summary
    observations can be registered per submitted assertion, grouped
    by common citation, study type, origin, ethnicity, tissue, cell
    line, and species data. Not all options are valid per study
    type, but these will not be validated in the xsd."""
    subclass = None
    superclass = None
    def __init__(self, Sample=None, Method=None, ObservedData=None, Co_occurrenceSet=None, TraitSet=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Sample = Sample
        if Method is None:
            self.Method = []
        else:
            self.Method = Method
        if ObservedData is None:
            self.ObservedData = []
        else:
            self.ObservedData = ObservedData
        if Co_occurrenceSet is None:
            self.Co_occurrenceSet = []
        else:
            self.Co_occurrenceSet = Co_occurrenceSet
        self.TraitSet = TraitSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ObservationSet.subclass:
            return ObservationSet.subclass(*args_, **kwargs_)
        else:
            return ObservationSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sample(self): return self.Sample
    def set_Sample(self, Sample): self.Sample = Sample
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def add_Method(self, value): self.Method.append(value)
    def insert_Method_at(self, index, value): self.Method.insert(index, value)
    def replace_Method_at(self, index, value): self.Method[index] = value
    def get_ObservedData(self): return self.ObservedData
    def set_ObservedData(self, ObservedData): self.ObservedData = ObservedData
    def add_ObservedData(self, value): self.ObservedData.append(value)
    def insert_ObservedData_at(self, index, value): self.ObservedData.insert(index, value)
    def replace_ObservedData_at(self, index, value): self.ObservedData[index] = value
    def get_Co_occurrenceSet(self): return self.Co_occurrenceSet
    def set_Co_occurrenceSet(self, Co_occurrenceSet): self.Co_occurrenceSet = Co_occurrenceSet
    def add_Co_occurrenceSet(self, value): self.Co_occurrenceSet.append(value)
    def insert_Co_occurrenceSet_at(self, index, value): self.Co_occurrenceSet.insert(index, value)
    def replace_Co_occurrenceSet_at(self, index, value): self.Co_occurrenceSet[index] = value
    def get_TraitSet(self): return self.TraitSet
    def set_TraitSet(self, TraitSet): self.TraitSet = TraitSet
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Sample is not None or
            self.Method or
            self.ObservedData or
            self.Co_occurrenceSet or
            self.TraitSet is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservationSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservationSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservationSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservationSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ObservationSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sample is not None:
            self.Sample.export(outfile, level, namespace_, name_='Sample', pretty_print=pretty_print)
        for Method_ in self.Method:
            Method_.export(outfile, level, namespace_, name_='Method', pretty_print=pretty_print)
        for ObservedData_ in self.ObservedData:
            ObservedData_.export(outfile, level, namespace_, name_='ObservedData', pretty_print=pretty_print)
        for Co_occurrenceSet_ in self.Co_occurrenceSet:
            Co_occurrenceSet_.export(outfile, level, namespace_, name_='Co-occurrenceSet', pretty_print=pretty_print)
        if self.TraitSet is not None:
            self.TraitSet.export(outfile, level, namespace_, name_='TraitSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObservationSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Sample is not None:
            showIndent(outfile, level)
            outfile.write('Sample=model_.SampleType(\n')
            self.Sample.exportLiteral(outfile, level, name_='Sample')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Method=[\n')
        level += 1
        for Method_ in self.Method:
            showIndent(outfile, level)
            outfile.write('model_.MethodType20(\n')
            Method_.exportLiteral(outfile, level, name_='MethodType20')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ObservedData=[\n')
        level += 1
        for ObservedData_ in self.ObservedData:
            showIndent(outfile, level)
            outfile.write('model_.ObservedDataType(\n')
            ObservedData_.exportLiteral(outfile, level, name_='ObservedDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Co_occurrenceSet=[\n')
        level += 1
        for Co_occurrenceSet_ in self.Co_occurrenceSet:
            showIndent(outfile, level)
            outfile.write('model_.Co_occurrenceType(\n')
            Co_occurrenceSet_.exportLiteral(outfile, level, name_='Co-occurrenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TraitSet is not None:
            showIndent(outfile, level)
            outfile.write('TraitSet=model_.TraitSetType(\n')
            self.TraitSet.exportLiteral(outfile, level, name_='TraitSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sample':
            obj_ = SampleType.factory()
            obj_.build(child_)
            self.Sample = obj_
            obj_.original_tagname_ = 'Sample'
        elif nodeName_ == 'Method':
            obj_ = MethodType20.factory()
            obj_.build(child_)
            self.Method.append(obj_)
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'ObservedData':
            obj_ = ObservedDataType.factory()
            obj_.build(child_)
            self.ObservedData.append(obj_)
            obj_.original_tagname_ = 'ObservedData'
        elif nodeName_ == 'Co-occurrenceSet':
            obj_ = Co_occurrenceType.factory()
            obj_.build(child_)
            self.Co_occurrenceSet.append(obj_)
            obj_.original_tagname_ = 'Co-occurrenceSet'
        elif nodeName_ == 'TraitSet':
            obj_ = TraitSetType.factory()
            obj_.build(child_)
            self.TraitSet = obj_
            obj_.original_tagname_ = 'TraitSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ObservationSet


class FamilyInfo(GeneratedsSuper):
    """Structure to describe attributes of any family data in an
    observation. If the details of the number of families and the
    de-identified pedigree id are not available, use FamilyHistory
    to describe what type of family data is available. Can also be
    used to report 'Yes' or 'No' if there are no more details."""
    subclass = None
    superclass = None
    def __init__(self, PedigreeID=None, NumFamiliesWithVariant=None, NumFamiliesWithSegregationObserved=None, NumFamilies=None, FamilyHistory=None):
        self.original_tagname_ = None
        self.PedigreeID = _cast(None, PedigreeID)
        self.NumFamiliesWithVariant = _cast(int, NumFamiliesWithVariant)
        self.NumFamiliesWithSegregationObserved = _cast(int, NumFamiliesWithSegregationObserved)
        self.NumFamilies = _cast(int, NumFamilies)
        self.FamilyHistory = FamilyHistory
    def factory(*args_, **kwargs_):
        if FamilyInfo.subclass:
            return FamilyInfo.subclass(*args_, **kwargs_)
        else:
            return FamilyInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FamilyHistory(self): return self.FamilyHistory
    def set_FamilyHistory(self, FamilyHistory): self.FamilyHistory = FamilyHistory
    def get_PedigreeID(self): return self.PedigreeID
    def set_PedigreeID(self, PedigreeID): self.PedigreeID = PedigreeID
    def get_NumFamiliesWithVariant(self): return self.NumFamiliesWithVariant
    def set_NumFamiliesWithVariant(self, NumFamiliesWithVariant): self.NumFamiliesWithVariant = NumFamiliesWithVariant
    def get_NumFamiliesWithSegregationObserved(self): return self.NumFamiliesWithSegregationObserved
    def set_NumFamiliesWithSegregationObserved(self, NumFamiliesWithSegregationObserved): self.NumFamiliesWithSegregationObserved = NumFamiliesWithSegregationObserved
    def get_NumFamilies(self): return self.NumFamilies
    def set_NumFamilies(self, NumFamilies): self.NumFamilies = NumFamilies
    def hasContent_(self):
        if (
            self.FamilyHistory is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FamilyInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FamilyInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FamilyInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FamilyInfo'):
        if self.PedigreeID is not None and 'PedigreeID' not in already_processed:
            already_processed.add('PedigreeID')
            outfile.write(' PedigreeID=%s' % (self.gds_format_string(quote_attrib(self.PedigreeID).encode(ExternalEncoding), input_name='PedigreeID'), ))
        if self.NumFamiliesWithVariant is not None and 'NumFamiliesWithVariant' not in already_processed:
            already_processed.add('NumFamiliesWithVariant')
            outfile.write(' NumFamiliesWithVariant="%s"' % self.gds_format_integer(self.NumFamiliesWithVariant, input_name='NumFamiliesWithVariant'))
        if self.NumFamiliesWithSegregationObserved is not None and 'NumFamiliesWithSegregationObserved' not in already_processed:
            already_processed.add('NumFamiliesWithSegregationObserved')
            outfile.write(' NumFamiliesWithSegregationObserved="%s"' % self.gds_format_integer(self.NumFamiliesWithSegregationObserved, input_name='NumFamiliesWithSegregationObserved'))
        if self.NumFamilies is not None and 'NumFamilies' not in already_processed:
            already_processed.add('NumFamilies')
            outfile.write(' NumFamilies="%s"' % self.gds_format_integer(self.NumFamilies, input_name='NumFamilies'))
    def exportChildren(self, outfile, level, namespace_='', name_='FamilyInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FamilyHistory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFamilyHistory>%s</%sFamilyHistory>%s' % (namespace_, self.gds_format_string(quote_xml(self.FamilyHistory).encode(ExternalEncoding), input_name='FamilyHistory'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FamilyInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PedigreeID is not None and 'PedigreeID' not in already_processed:
            already_processed.add('PedigreeID')
            showIndent(outfile, level)
            outfile.write('PedigreeID="%s",\n' % (self.PedigreeID,))
        if self.NumFamiliesWithVariant is not None and 'NumFamiliesWithVariant' not in already_processed:
            already_processed.add('NumFamiliesWithVariant')
            showIndent(outfile, level)
            outfile.write('NumFamiliesWithVariant=%d,\n' % (self.NumFamiliesWithVariant,))
        if self.NumFamiliesWithSegregationObserved is not None and 'NumFamiliesWithSegregationObserved' not in already_processed:
            already_processed.add('NumFamiliesWithSegregationObserved')
            showIndent(outfile, level)
            outfile.write('NumFamiliesWithSegregationObserved=%d,\n' % (self.NumFamiliesWithSegregationObserved,))
        if self.NumFamilies is not None and 'NumFamilies' not in already_processed:
            already_processed.add('NumFamilies')
            showIndent(outfile, level)
            outfile.write('NumFamilies=%d,\n' % (self.NumFamilies,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FamilyHistory is not None:
            showIndent(outfile, level)
            outfile.write('FamilyHistory=%s,\n' % quote_python(self.FamilyHistory).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PedigreeID', node)
        if value is not None and 'PedigreeID' not in already_processed:
            already_processed.add('PedigreeID')
            self.PedigreeID = value
        value = find_attr_value_('NumFamiliesWithVariant', node)
        if value is not None and 'NumFamiliesWithVariant' not in already_processed:
            already_processed.add('NumFamiliesWithVariant')
            try:
                self.NumFamiliesWithVariant = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NumFamiliesWithSegregationObserved', node)
        if value is not None and 'NumFamiliesWithSegregationObserved' not in already_processed:
            already_processed.add('NumFamiliesWithSegregationObserved')
            try:
                self.NumFamiliesWithSegregationObserved = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NumFamilies', node)
        if value is not None and 'NumFamilies' not in already_processed:
            already_processed.add('NumFamilies')
            try:
                self.NumFamilies = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FamilyHistory':
            FamilyHistory_ = child_.text
            FamilyHistory_ = self.gds_validate_string(FamilyHistory_, node, 'FamilyHistory')
            self.FamilyHistory = FamilyHistory_
# end class FamilyInfo


class SampleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SampleDescription=None, Origin=None, Ethnicity=None, GeographicOrigin=None, Tissue=None, CellLine=None, Species=None, Age=None, Strain=None, AffectedStatus=None, NumberTested=None, NumberMales=None, NumberFemales=None, NumberChrTested=None, Gender=None, FamilyData=None, Proband=None, Indication=None, Citation=None, XRef=None, Comment=None, SourceType=None):
        self.original_tagname_ = None
        self.SampleDescription = SampleDescription
        self.Origin = Origin
        self.validate_OriginType(self.Origin)
        self.Ethnicity = Ethnicity
        self.GeographicOrigin = GeographicOrigin
        self.Tissue = Tissue
        self.CellLine = CellLine
        self.Species = Species
        if Age is None:
            self.Age = []
        else:
            self.Age = Age
        self.Strain = Strain
        self.AffectedStatus = AffectedStatus
        self.validate_AffectedStatusType(self.AffectedStatus)
        self.NumberTested = NumberTested
        self.NumberMales = NumberMales
        self.NumberFemales = NumberFemales
        self.NumberChrTested = NumberChrTested
        self.Gender = Gender
        self.validate_GenderType(self.Gender)
        self.FamilyData = FamilyData
        self.Proband = Proband
        self.Indication = Indication
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.SourceType = SourceType
        self.validate_SourceTypeType22(self.SourceType)
    def factory(*args_, **kwargs_):
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SampleDescription(self): return self.SampleDescription
    def set_SampleDescription(self, SampleDescription): self.SampleDescription = SampleDescription
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    def get_Ethnicity(self): return self.Ethnicity
    def set_Ethnicity(self, Ethnicity): self.Ethnicity = Ethnicity
    def get_GeographicOrigin(self): return self.GeographicOrigin
    def set_GeographicOrigin(self, GeographicOrigin): self.GeographicOrigin = GeographicOrigin
    def get_Tissue(self): return self.Tissue
    def set_Tissue(self, Tissue): self.Tissue = Tissue
    def get_CellLine(self): return self.CellLine
    def set_CellLine(self, CellLine): self.CellLine = CellLine
    def get_Species(self): return self.Species
    def set_Species(self, Species): self.Species = Species
    def get_Age(self): return self.Age
    def set_Age(self, Age): self.Age = Age
    def add_Age(self, value): self.Age.append(value)
    def insert_Age_at(self, index, value): self.Age.insert(index, value)
    def replace_Age_at(self, index, value): self.Age[index] = value
    def get_Strain(self): return self.Strain
    def set_Strain(self, Strain): self.Strain = Strain
    def get_AffectedStatus(self): return self.AffectedStatus
    def set_AffectedStatus(self, AffectedStatus): self.AffectedStatus = AffectedStatus
    def get_NumberTested(self): return self.NumberTested
    def set_NumberTested(self, NumberTested): self.NumberTested = NumberTested
    def get_NumberMales(self): return self.NumberMales
    def set_NumberMales(self, NumberMales): self.NumberMales = NumberMales
    def get_NumberFemales(self): return self.NumberFemales
    def set_NumberFemales(self, NumberFemales): self.NumberFemales = NumberFemales
    def get_NumberChrTested(self): return self.NumberChrTested
    def set_NumberChrTested(self, NumberChrTested): self.NumberChrTested = NumberChrTested
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def get_FamilyData(self): return self.FamilyData
    def set_FamilyData(self, FamilyData): self.FamilyData = FamilyData
    def get_Proband(self): return self.Proband
    def set_Proband(self, Proband): self.Proband = Proband
    def get_Indication(self): return self.Indication
    def set_Indication(self, Indication): self.Indication = Indication
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def validate_OriginType(self, value):
        # Validate type OriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['germline', 'somatic', 'de novo', 'unknown', 'not provided', 'inherited', 'maternal', 'paternal', 'uniparental', 'biparental', 'not-reported', 'tested-inconclusive', 'not applicable', 'experimentally generated']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OriginType' % {"value" : value.encode("utf-8")} )
    def validate_AffectedStatusType(self, value):
        # Validate type AffectedStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'not provided', 'unknown', 'not applicable']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AffectedStatusType' % {"value" : value.encode("utf-8")} )
    def validate_GenderType(self, value):
        # Validate type GenderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['male', 'female', 'mixed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GenderType' % {"value" : value.encode("utf-8")} )
    def validate_SourceTypeType22(self, value):
        # Validate type SourceTypeType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['submitter-generated', 'data mining']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SourceTypeType22' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SampleDescription is not None or
            self.Origin is not None or
            self.Ethnicity is not None or
            self.GeographicOrigin is not None or
            self.Tissue is not None or
            self.CellLine is not None or
            self.Species is not None or
            self.Age or
            self.Strain is not None or
            self.AffectedStatus is not None or
            self.NumberTested is not None or
            self.NumberMales is not None or
            self.NumberFemales is not None or
            self.NumberChrTested is not None or
            self.Gender is not None or
            self.FamilyData is not None or
            self.Proband is not None or
            self.Indication is not None or
            self.Citation or
            self.XRef or
            self.Comment or
            self.SourceType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SampleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SampleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SampleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SampleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SampleDescription is not None:
            self.SampleDescription.export(outfile, level, namespace_, name_='SampleDescription', pretty_print=pretty_print)
        if self.Origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrigin>%s</%sOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.Origin).encode(ExternalEncoding), input_name='Origin'), namespace_, eol_))
        if self.Ethnicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEthnicity>%s</%sEthnicity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ethnicity).encode(ExternalEncoding), input_name='Ethnicity'), namespace_, eol_))
        if self.GeographicOrigin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGeographicOrigin>%s</%sGeographicOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.GeographicOrigin).encode(ExternalEncoding), input_name='GeographicOrigin'), namespace_, eol_))
        if self.Tissue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTissue>%s</%sTissue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Tissue).encode(ExternalEncoding), input_name='Tissue'), namespace_, eol_))
        if self.CellLine is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCellLine>%s</%sCellLine>%s' % (namespace_, self.gds_format_string(quote_xml(self.CellLine).encode(ExternalEncoding), input_name='CellLine'), namespace_, eol_))
        if self.Species is not None:
            self.Species.export(outfile, level, namespace_, name_='Species', pretty_print=pretty_print)
        for Age_ in self.Age:
            Age_.export(outfile, level, namespace_, name_='Age', pretty_print=pretty_print)
        if self.Strain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrain>%s</%sStrain>%s' % (namespace_, self.gds_format_string(quote_xml(self.Strain).encode(ExternalEncoding), input_name='Strain'), namespace_, eol_))
        if self.AffectedStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAffectedStatus>%s</%sAffectedStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.AffectedStatus).encode(ExternalEncoding), input_name='AffectedStatus'), namespace_, eol_))
        if self.NumberTested is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberTested>%s</%sNumberTested>%s' % (namespace_, self.gds_format_integer(self.NumberTested, input_name='NumberTested'), namespace_, eol_))
        if self.NumberMales is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberMales>%s</%sNumberMales>%s' % (namespace_, self.gds_format_integer(self.NumberMales, input_name='NumberMales'), namespace_, eol_))
        if self.NumberFemales is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberFemales>%s</%sNumberFemales>%s' % (namespace_, self.gds_format_integer(self.NumberFemales, input_name='NumberFemales'), namespace_, eol_))
        if self.NumberChrTested is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberChrTested>%s</%sNumberChrTested>%s' % (namespace_, self.gds_format_integer(self.NumberChrTested, input_name='NumberChrTested'), namespace_, eol_))
        if self.Gender is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGender>%s</%sGender>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gender).encode(ExternalEncoding), input_name='Gender'), namespace_, eol_))
        if self.FamilyData is not None:
            self.FamilyData.export(outfile, level, namespace_, name_='FamilyData', pretty_print=pretty_print)
        if self.Proband is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProband>%s</%sProband>%s' % (namespace_, self.gds_format_string(quote_xml(self.Proband).encode(ExternalEncoding), input_name='Proband'), namespace_, eol_))
        if self.Indication is not None:
            self.Indication.export(outfile, level, namespace_, name_='Indication', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.SourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceType>%s</%sSourceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SampleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SampleDescription is not None:
            showIndent(outfile, level)
            outfile.write('SampleDescription=model_.SampleDescriptionType(\n')
            self.SampleDescription.exportLiteral(outfile, level, name_='SampleDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Origin is not None:
            showIndent(outfile, level)
            outfile.write('Origin=%s,\n' % quote_python(self.Origin).encode(ExternalEncoding))
        if self.Ethnicity is not None:
            showIndent(outfile, level)
            outfile.write('Ethnicity=%s,\n' % quote_python(self.Ethnicity).encode(ExternalEncoding))
        if self.GeographicOrigin is not None:
            showIndent(outfile, level)
            outfile.write('GeographicOrigin=%s,\n' % quote_python(self.GeographicOrigin).encode(ExternalEncoding))
        if self.Tissue is not None:
            showIndent(outfile, level)
            outfile.write('Tissue=%s,\n' % quote_python(self.Tissue).encode(ExternalEncoding))
        if self.CellLine is not None:
            showIndent(outfile, level)
            outfile.write('CellLine=%s,\n' % quote_python(self.CellLine).encode(ExternalEncoding))
        if self.Species is not None:
            showIndent(outfile, level)
            outfile.write('Species=model_.SpeciesType(\n')
            self.Species.exportLiteral(outfile, level, name_='Species')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Age=[\n')
        level += 1
        for Age_ in self.Age:
            showIndent(outfile, level)
            outfile.write('model_.AgeType(\n')
            Age_.exportLiteral(outfile, level, name_='AgeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Strain is not None:
            showIndent(outfile, level)
            outfile.write('Strain=%s,\n' % quote_python(self.Strain).encode(ExternalEncoding))
        if self.AffectedStatus is not None:
            showIndent(outfile, level)
            outfile.write('AffectedStatus=%s,\n' % quote_python(self.AffectedStatus).encode(ExternalEncoding))
        if self.NumberTested is not None:
            showIndent(outfile, level)
            outfile.write('NumberTested=%d,\n' % self.NumberTested)
        if self.NumberMales is not None:
            showIndent(outfile, level)
            outfile.write('NumberMales=%d,\n' % self.NumberMales)
        if self.NumberFemales is not None:
            showIndent(outfile, level)
            outfile.write('NumberFemales=%d,\n' % self.NumberFemales)
        if self.NumberChrTested is not None:
            showIndent(outfile, level)
            outfile.write('NumberChrTested=%d,\n' % self.NumberChrTested)
        if self.Gender is not None:
            showIndent(outfile, level)
            outfile.write('Gender=%s,\n' % quote_python(self.Gender).encode(ExternalEncoding))
        if self.FamilyData is not None:
            showIndent(outfile, level)
            outfile.write('FamilyData=model_.FamilyInfo(\n')
            self.FamilyData.exportLiteral(outfile, level, name_='FamilyData')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Proband is not None:
            showIndent(outfile, level)
            outfile.write('Proband=%s,\n' % quote_python(self.Proband).encode(ExternalEncoding))
        if self.Indication is not None:
            showIndent(outfile, level)
            outfile.write('Indication=model_.IndicationType(\n')
            self.Indication.exportLiteral(outfile, level, name_='Indication')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SourceType is not None:
            showIndent(outfile, level)
            outfile.write('SourceType=%s,\n' % quote_python(self.SourceType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SampleDescription':
            obj_ = SampleDescriptionType.factory()
            obj_.build(child_)
            self.SampleDescription = obj_
            obj_.original_tagname_ = 'SampleDescription'
        elif nodeName_ == 'Origin':
            Origin_ = child_.text
            Origin_ = self.gds_validate_string(Origin_, node, 'Origin')
            self.Origin = Origin_
            self.validate_OriginType(self.Origin)    # validate type OriginType
        elif nodeName_ == 'Ethnicity':
            Ethnicity_ = child_.text
            Ethnicity_ = self.gds_validate_string(Ethnicity_, node, 'Ethnicity')
            self.Ethnicity = Ethnicity_
        elif nodeName_ == 'GeographicOrigin':
            GeographicOrigin_ = child_.text
            GeographicOrigin_ = self.gds_validate_string(GeographicOrigin_, node, 'GeographicOrigin')
            self.GeographicOrigin = GeographicOrigin_
        elif nodeName_ == 'Tissue':
            Tissue_ = child_.text
            Tissue_ = self.gds_validate_string(Tissue_, node, 'Tissue')
            self.Tissue = Tissue_
        elif nodeName_ == 'CellLine':
            CellLine_ = child_.text
            CellLine_ = self.gds_validate_string(CellLine_, node, 'CellLine')
            self.CellLine = CellLine_
        elif nodeName_ == 'Species':
            obj_ = SpeciesType.factory()
            obj_.build(child_)
            self.Species = obj_
            obj_.original_tagname_ = 'Species'
        elif nodeName_ == 'Age':
            obj_ = AgeType.factory()
            obj_.build(child_)
            self.Age.append(obj_)
            obj_.original_tagname_ = 'Age'
        elif nodeName_ == 'Strain':
            Strain_ = child_.text
            Strain_ = self.gds_validate_string(Strain_, node, 'Strain')
            self.Strain = Strain_
        elif nodeName_ == 'AffectedStatus':
            AffectedStatus_ = child_.text
            AffectedStatus_ = self.gds_validate_string(AffectedStatus_, node, 'AffectedStatus')
            self.AffectedStatus = AffectedStatus_
            self.validate_AffectedStatusType(self.AffectedStatus)    # validate type AffectedStatusType
        elif nodeName_ == 'NumberTested':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberTested')
            self.NumberTested = ival_
        elif nodeName_ == 'NumberMales':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberMales')
            self.NumberMales = ival_
        elif nodeName_ == 'NumberFemales':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberFemales')
            self.NumberFemales = ival_
        elif nodeName_ == 'NumberChrTested':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberChrTested')
            self.NumberChrTested = ival_
        elif nodeName_ == 'Gender':
            Gender_ = child_.text
            Gender_ = self.gds_validate_string(Gender_, node, 'Gender')
            self.Gender = Gender_
            self.validate_GenderType(self.Gender)    # validate type GenderType
        elif nodeName_ == 'FamilyData':
            obj_ = FamilyInfo.factory()
            obj_.build(child_)
            self.FamilyData = obj_
            obj_.original_tagname_ = 'FamilyData'
        elif nodeName_ == 'Proband':
            Proband_ = child_.text
            Proband_ = self.gds_validate_string(Proband_, node, 'Proband')
            self.Proband = Proband_
        elif nodeName_ == 'Indication':
            obj_ = IndicationType.factory()
            obj_.build(child_)
            self.Indication = obj_
            obj_.original_tagname_ = 'Indication'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'SourceType':
            SourceType_ = child_.text
            SourceType_ = self.gds_validate_string(SourceType_, node, 'SourceType')
            self.SourceType = SourceType_
            self.validate_SourceTypeType22(self.SourceType)    # validate type SourceTypeType22
# end class SampleType


class Co_occurrenceType(GeneratedsSuper):
    """This refers to the zygosity of the variant being asserted."""
    subclass = None
    superclass = None
    def __init__(self, Zygosity=None, AlleleDescSet=None, Count=None):
        self.original_tagname_ = None
        self.Zygosity = Zygosity
        self.validate_ZygosityType(self.Zygosity)
        if AlleleDescSet is None:
            self.AlleleDescSet = []
        else:
            self.AlleleDescSet = AlleleDescSet
        self.Count = Count
    def factory(*args_, **kwargs_):
        if Co_occurrenceType.subclass:
            return Co_occurrenceType.subclass(*args_, **kwargs_)
        else:
            return Co_occurrenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Zygosity(self): return self.Zygosity
    def set_Zygosity(self, Zygosity): self.Zygosity = Zygosity
    def get_AlleleDescSet(self): return self.AlleleDescSet
    def set_AlleleDescSet(self, AlleleDescSet): self.AlleleDescSet = AlleleDescSet
    def add_AlleleDescSet(self, value): self.AlleleDescSet.append(value)
    def insert_AlleleDescSet_at(self, index, value): self.AlleleDescSet.insert(index, value)
    def replace_AlleleDescSet_at(self, index, value): self.AlleleDescSet[index] = value
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    def validate_ZygosityType(self, value):
        # Validate type ZygosityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Homozygote', 'SingleHeterozygote', 'CompoundHeterozygote', 'Hemizygote', 'not provided']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ZygosityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Zygosity is not None or
            self.AlleleDescSet or
            self.Count is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Co-occurrenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Co-occurrenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Co-occurrenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Co-occurrenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Co-occurrenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Zygosity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZygosity>%s</%sZygosity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Zygosity).encode(ExternalEncoding), input_name='Zygosity'), namespace_, eol_))
        for AlleleDescSet_ in self.AlleleDescSet:
            AlleleDescSet_.export(outfile, level, namespace_, name_='AlleleDescSet', pretty_print=pretty_print)
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (namespace_, self.gds_format_integer(self.Count, input_name='Count'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Co-occurrenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Zygosity is not None:
            showIndent(outfile, level)
            outfile.write('Zygosity=%s,\n' % quote_python(self.Zygosity).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AlleleDescSet=[\n')
        level += 1
        for AlleleDescSet_ in self.AlleleDescSet:
            showIndent(outfile, level)
            outfile.write('model_.AlleleDescType(\n')
            AlleleDescSet_.exportLiteral(outfile, level, name_='AlleleDescType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Count is not None:
            showIndent(outfile, level)
            outfile.write('Count=%d,\n' % self.Count)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Zygosity':
            Zygosity_ = child_.text
            Zygosity_ = self.gds_validate_string(Zygosity_, node, 'Zygosity')
            self.Zygosity = Zygosity_
            self.validate_ZygosityType(self.Zygosity)    # validate type ZygosityType
        elif nodeName_ == 'AlleleDescSet':
            obj_ = AlleleDescType.factory()
            obj_.build(child_)
            self.AlleleDescSet.append(obj_)
            obj_.original_tagname_ = 'AlleleDescSet'
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
# end class Co_occurrenceType


class ClinicalSignificanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DateLastEvaluated=None, ReviewStatus=None, Description=None, Explanation=None, XRef=None, Citation=None, Comment=None):
        self.original_tagname_ = None
        if isinstance(DateLastEvaluated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateLastEvaluated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastEvaluated
        self.DateLastEvaluated = initvalue_
        self.ReviewStatus = ReviewStatus
        self.validate_ReviewStatusType(self.ReviewStatus)
        self.Description = Description
        self.Explanation = Explanation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ClinicalSignificanceType.subclass:
            return ClinicalSignificanceType.subclass(*args_, **kwargs_)
        else:
            return ClinicalSignificanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReviewStatus(self): return self.ReviewStatus
    def set_ReviewStatus(self, ReviewStatus): self.ReviewStatus = ReviewStatus
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Explanation(self): return self.Explanation
    def set_Explanation(self, Explanation): self.Explanation = Explanation
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_DateLastEvaluated(self): return self.DateLastEvaluated
    def set_DateLastEvaluated(self, DateLastEvaluated): self.DateLastEvaluated = DateLastEvaluated
    def validate_ReviewStatusType(self, value):
        # Validate type ReviewStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['not classified by submitter', 'classified by single submitter', 'classified by multiple submitters', 'reviewed by expert panel', 'reviewed by professional society']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReviewStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReviewStatus is not None or
            self.Description is not None or
            self.Explanation is not None or
            self.XRef or
            self.Citation or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClinicalSignificanceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClinicalSignificanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClinicalSignificanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClinicalSignificanceType'):
        if self.DateLastEvaluated is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            outfile.write(' DateLastEvaluated="%s"' % self.gds_format_date(self.DateLastEvaluated, input_name='DateLastEvaluated'))
    def exportChildren(self, outfile, level, namespace_='', name_='ClinicalSignificanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReviewStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReviewStatus>%s</%sReviewStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReviewStatus).encode(ExternalEncoding), input_name='ReviewStatus'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Explanation is not None:
            self.Explanation.export(outfile, level, namespace_, name_='Explanation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ClinicalSignificanceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DateLastEvaluated is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            showIndent(outfile, level)
            outfile.write('DateLastEvaluated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateLastEvaluated, input_name='DateLastEvaluated'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ReviewStatus is not None:
            showIndent(outfile, level)
            outfile.write('ReviewStatus=%s,\n' % quote_python(self.ReviewStatus).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Explanation is not None:
            showIndent(outfile, level)
            outfile.write('Explanation=model_.CommentType(\n')
            self.Explanation.exportLiteral(outfile, level, name_='Explanation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DateLastEvaluated', node)
        if value is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            try:
                self.DateLastEvaluated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateLastEvaluated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReviewStatus':
            ReviewStatus_ = child_.text
            ReviewStatus_ = self.gds_validate_string(ReviewStatus_, node, 'ReviewStatus')
            self.ReviewStatus = ReviewStatus_
            self.validate_ReviewStatusType(self.ReviewStatus)    # validate type ReviewStatusType
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Explanation':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Explanation = obj_
            obj_.original_tagname_ = 'Explanation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ClinicalSignificanceType


class ClinicalSignificanceTypeSCV(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DateLastEvaluated=None, ReviewStatus=None, Description=None, Explanation=None, XRef=None, Citation=None, Comment=None):
        self.original_tagname_ = None
        if isinstance(DateLastEvaluated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateLastEvaluated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastEvaluated
        self.DateLastEvaluated = initvalue_
        self.ReviewStatus = ReviewStatus
        self.validate_ReviewStatusType(self.ReviewStatus)
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Explanation = Explanation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ClinicalSignificanceTypeSCV.subclass:
            return ClinicalSignificanceTypeSCV.subclass(*args_, **kwargs_)
        else:
            return ClinicalSignificanceTypeSCV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReviewStatus(self): return self.ReviewStatus
    def set_ReviewStatus(self, ReviewStatus): self.ReviewStatus = ReviewStatus
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Explanation(self): return self.Explanation
    def set_Explanation(self, Explanation): self.Explanation = Explanation
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_DateLastEvaluated(self): return self.DateLastEvaluated
    def set_DateLastEvaluated(self, DateLastEvaluated): self.DateLastEvaluated = DateLastEvaluated
    def validate_ReviewStatusType(self, value):
        # Validate type ReviewStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['not classified by submitter', 'classified by single submitter', 'classified by multiple submitters', 'reviewed by expert panel', 'reviewed by professional society']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReviewStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReviewStatus is not None or
            self.Description or
            self.Explanation is not None or
            self.XRef or
            self.Citation or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClinicalSignificanceTypeSCV', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClinicalSignificanceTypeSCV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClinicalSignificanceTypeSCV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClinicalSignificanceTypeSCV'):
        if self.DateLastEvaluated is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            outfile.write(' DateLastEvaluated="%s"' % self.gds_format_date(self.DateLastEvaluated, input_name='DateLastEvaluated'))
    def exportChildren(self, outfile, level, namespace_='', name_='ClinicalSignificanceTypeSCV', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReviewStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReviewStatus>%s</%sReviewStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReviewStatus).encode(ExternalEncoding), input_name='ReviewStatus'), namespace_, eol_))
        for Description_ in self.Description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(Description_).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Explanation is not None:
            self.Explanation.export(outfile, level, namespace_, name_='Explanation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ClinicalSignificanceTypeSCV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DateLastEvaluated is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            showIndent(outfile, level)
            outfile.write('DateLastEvaluated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateLastEvaluated, input_name='DateLastEvaluated'))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ReviewStatus is not None:
            showIndent(outfile, level)
            outfile.write('ReviewStatus=%s,\n' % quote_python(self.ReviewStatus).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Explanation is not None:
            showIndent(outfile, level)
            outfile.write('Explanation=model_.CommentType(\n')
            self.Explanation.exportLiteral(outfile, level, name_='Explanation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DateLastEvaluated', node)
        if value is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            try:
                self.DateLastEvaluated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateLastEvaluated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReviewStatus':
            ReviewStatus_ = child_.text
            ReviewStatus_ = self.gds_validate_string(ReviewStatus_, node, 'ReviewStatus')
            self.ReviewStatus = ReviewStatus_
            self.validate_ReviewStatusType(self.ReviewStatus)    # validate type ReviewStatusType
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description.append(Description_)
        elif nodeName_ == 'Explanation':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Explanation = obj_
            obj_.original_tagname_ = 'Explanation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ClinicalSignificanceTypeSCV


class AlleleDescType(GeneratedsSuper):
    """This is to be used within co-occurrence set"""
    subclass = None
    superclass = None
    def __init__(self, Name=None, RelativeOrientation=None, Zygosity=None, ClinicalSignificance=None):
        self.original_tagname_ = None
        self.Name = Name
        self.RelativeOrientation = RelativeOrientation
        self.validate_RelativeOrientationType(self.RelativeOrientation)
        self.Zygosity = Zygosity
        self.validate_ZygosityType(self.Zygosity)
        self.ClinicalSignificance = ClinicalSignificance
    def factory(*args_, **kwargs_):
        if AlleleDescType.subclass:
            return AlleleDescType.subclass(*args_, **kwargs_)
        else:
            return AlleleDescType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_RelativeOrientation(self): return self.RelativeOrientation
    def set_RelativeOrientation(self, RelativeOrientation): self.RelativeOrientation = RelativeOrientation
    def get_Zygosity(self): return self.Zygosity
    def set_Zygosity(self, Zygosity): self.Zygosity = Zygosity
    def get_ClinicalSignificance(self): return self.ClinicalSignificance
    def set_ClinicalSignificance(self, ClinicalSignificance): self.ClinicalSignificance = ClinicalSignificance
    def validate_RelativeOrientationType(self, value):
        # Validate type RelativeOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cis', 'trans', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RelativeOrientationType' % {"value" : value.encode("utf-8")} )
    def validate_ZygosityType(self, value):
        # Validate type ZygosityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Homozygote', 'SingleHeterozygote', 'CompoundHeterozygote', 'Hemizygote', 'not provided']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ZygosityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.RelativeOrientation is not None or
            self.Zygosity is not None or
            self.ClinicalSignificance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AlleleDescType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlleleDescType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AlleleDescType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AlleleDescType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AlleleDescType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.RelativeOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelativeOrientation>%s</%sRelativeOrientation>%s' % (namespace_, self.gds_format_string(quote_xml(self.RelativeOrientation).encode(ExternalEncoding), input_name='RelativeOrientation'), namespace_, eol_))
        if self.Zygosity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZygosity>%s</%sZygosity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Zygosity).encode(ExternalEncoding), input_name='Zygosity'), namespace_, eol_))
        if self.ClinicalSignificance is not None:
            self.ClinicalSignificance.export(outfile, level, namespace_, name_='ClinicalSignificance', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AlleleDescType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.RelativeOrientation is not None:
            showIndent(outfile, level)
            outfile.write('RelativeOrientation=%s,\n' % quote_python(self.RelativeOrientation).encode(ExternalEncoding))
        if self.Zygosity is not None:
            showIndent(outfile, level)
            outfile.write('Zygosity=%s,\n' % quote_python(self.Zygosity).encode(ExternalEncoding))
        if self.ClinicalSignificance is not None:
            showIndent(outfile, level)
            outfile.write('ClinicalSignificance=model_.ClinicalSignificanceType(\n')
            self.ClinicalSignificance.exportLiteral(outfile, level, name_='ClinicalSignificance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'RelativeOrientation':
            RelativeOrientation_ = child_.text
            RelativeOrientation_ = self.gds_validate_string(RelativeOrientation_, node, 'RelativeOrientation')
            self.RelativeOrientation = RelativeOrientation_
            self.validate_RelativeOrientationType(self.RelativeOrientation)    # validate type RelativeOrientationType
        elif nodeName_ == 'Zygosity':
            Zygosity_ = child_.text
            Zygosity_ = self.gds_validate_string(Zygosity_, node, 'Zygosity')
            self.Zygosity = Zygosity_
            self.validate_ZygosityType(self.Zygosity)    # validate type ZygosityType
        elif nodeName_ == 'ClinicalSignificance':
            obj_ = ClinicalSignificanceType.factory()
            obj_.build(child_)
            self.ClinicalSignificance = obj_
            obj_.original_tagname_ = 'ClinicalSignificance'
# end class AlleleDescType


class IndicationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Trait=None, Name=None, Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        self.Trait = Trait
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if IndicationType.subclass:
            return IndicationType.subclass(*args_, **kwargs_)
        else:
            return IndicationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trait(self): return self.Trait
    def set_Trait(self, Trait): self.Trait = Trait
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Trait is not None or
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.Citation or
            self.XRef or
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IndicationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IndicationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndicationType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndicationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Trait is not None:
            self.Trait.export(outfile, level, namespace_, name_='Trait', pretty_print=pretty_print)
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IndicationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Trait is not None:
            showIndent(outfile, level)
            outfile.write('Trait=model_.TraitType(\n')
            self.Trait.exportLiteral(outfile, level, name_='Trait')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Comment is not None:
            showIndent(outfile, level)
            outfile.write('Comment=model_.CommentType(\n')
            self.Comment.exportLiteral(outfile, level, name_='Comment')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trait':
            obj_ = TraitType.factory()
            obj_.build(child_)
            self.Trait = obj_
            obj_.original_tagname_ = 'Trait'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            class_obj_ = self.get_class_obj_(child_, AttributeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
# end class IndicationType


class AssertionTypeRCV(GeneratedsSuper):
    """Assertion is used to represent the type of relationship between the
    trait set and the measure set. This is stored in
    GTR.clinvar.measure_trait.relat_type."""
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if AssertionTypeRCV.subclass:
            return AssertionTypeRCV.subclass(*args_, **kwargs_)
        else:
            return AssertionTypeRCV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AssertionTypeAttr(self, value):
        # Validate type AssertionTypeAttr, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['variation to disease', 'variation in modifier gene to disease', 'confers sensitivity', 'confers resistance', 'variant to named protein']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssertionTypeAttr' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssertionTypeRCV', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssertionTypeRCV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssertionTypeRCV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssertionTypeRCV'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssertionTypeRCV', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AssertionTypeRCV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_AssertionTypeAttr(self.Type)    # validate type AssertionTypeAttr
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssertionTypeRCV


class AssertionTypeSCV(GeneratedsSuper):
    """Assertion is used to represent the type of relationship between the
    trait set and the measure set. This is stored in
    GTR.clinvar.measure_trait.relat_type."""
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if AssertionTypeSCV.subclass:
            return AssertionTypeSCV.subclass(*args_, **kwargs_)
        else:
            return AssertionTypeSCV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AssertionTypeAttrSCV(self, value):
        # Validate type AssertionTypeAttrSCV, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssertionTypeSCV', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssertionTypeSCV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssertionTypeSCV', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssertionTypeSCV'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AssertionTypeSCV', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AssertionTypeSCV'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_AssertionTypeAttrSCV(self.Type)    # validate type AssertionTypeAttrSCV
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AssertionTypeSCV


class SequenceLocationType(GeneratedsSuper):
    """Used to report the assembly, chromosome, and location of the
    measure."""
    subclass = None
    superclass = None
    def __init__(self, outerStart=None, Assembly=None, display_stop=None, start=None, stop=None, AssemblyAccessionVersion=None, Accession=None, innerStart=None, outerStop=None, innerStop=None, Chr=None, variantLength=None, display_start=None, AssemblyStatus=None, referenceAllele=None, alternateAllele=None, Strand=None):
        self.original_tagname_ = None
        self.outerStart = _cast(int, outerStart)
        self.Assembly = _cast(None, Assembly)
        self.display_stop = _cast(int, display_stop)
        self.start = _cast(int, start)
        self.stop = _cast(int, stop)
        self.AssemblyAccessionVersion = _cast(None, AssemblyAccessionVersion)
        self.Accession = _cast(None, Accession)
        self.innerStart = _cast(int, innerStart)
        self.outerStop = _cast(int, outerStop)
        self.innerStop = _cast(int, innerStop)
        self.Chr = _cast(None, Chr)
        self.variantLength = _cast(int, variantLength)
        self.display_start = _cast(int, display_start)
        self.AssemblyStatus = _cast(None, AssemblyStatus)
        self.referenceAllele = _cast(None, referenceAllele)
        self.alternateAllele = _cast(None, alternateAllele)
        self.Strand = _cast(None, Strand)
    def factory(*args_, **kwargs_):
        if SequenceLocationType.subclass:
            return SequenceLocationType.subclass(*args_, **kwargs_)
        else:
            return SequenceLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_outerStart(self): return self.outerStart
    def set_outerStart(self, outerStart): self.outerStart = outerStart
    def get_Assembly(self): return self.Assembly
    def set_Assembly(self, Assembly): self.Assembly = Assembly
    def get_display_stop(self): return self.display_stop
    def set_display_stop(self, display_stop): self.display_stop = display_stop
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_AssemblyAccessionVersion(self): return self.AssemblyAccessionVersion
    def set_AssemblyAccessionVersion(self, AssemblyAccessionVersion): self.AssemblyAccessionVersion = AssemblyAccessionVersion
    def get_Accession(self): return self.Accession
    def set_Accession(self, Accession): self.Accession = Accession
    def get_innerStart(self): return self.innerStart
    def set_innerStart(self, innerStart): self.innerStart = innerStart
    def get_outerStop(self): return self.outerStop
    def set_outerStop(self, outerStop): self.outerStop = outerStop
    def get_innerStop(self): return self.innerStop
    def set_innerStop(self, innerStop): self.innerStop = innerStop
    def get_Chr(self): return self.Chr
    def set_Chr(self, Chr): self.Chr = Chr
    def get_variantLength(self): return self.variantLength
    def set_variantLength(self, variantLength): self.variantLength = variantLength
    def get_display_start(self): return self.display_start
    def set_display_start(self, display_start): self.display_start = display_start
    def get_AssemblyStatus(self): return self.AssemblyStatus
    def set_AssemblyStatus(self, AssemblyStatus): self.AssemblyStatus = AssemblyStatus
    def get_referenceAllele(self): return self.referenceAllele
    def set_referenceAllele(self, referenceAllele): self.referenceAllele = referenceAllele
    def get_alternateAllele(self): return self.alternateAllele
    def set_alternateAllele(self, alternateAllele): self.alternateAllele = alternateAllele
    def get_Strand(self): return self.Strand
    def set_Strand(self, Strand): self.Strand = Strand
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequenceLocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequenceLocationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceLocationType'):
        if self.outerStart is not None and 'outerStart' not in already_processed:
            already_processed.add('outerStart')
            outfile.write(' outerStart="%s"' % self.gds_format_integer(self.outerStart, input_name='outerStart'))
        if self.Assembly is not None and 'Assembly' not in already_processed:
            already_processed.add('Assembly')
            outfile.write(' Assembly=%s' % (self.gds_format_string(quote_attrib(self.Assembly).encode(ExternalEncoding), input_name='Assembly'), ))
        if self.display_stop is not None and 'display_stop' not in already_processed:
            already_processed.add('display_stop')
            outfile.write(' display_stop="%s"' % self.gds_format_integer(self.display_stop, input_name='display_stop'))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start="%s"' % self.gds_format_integer(self.start, input_name='start'))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            outfile.write(' stop="%s"' % self.gds_format_integer(self.stop, input_name='stop'))
        if self.AssemblyAccessionVersion is not None and 'AssemblyAccessionVersion' not in already_processed:
            already_processed.add('AssemblyAccessionVersion')
            outfile.write(' AssemblyAccessionVersion=%s' % (self.gds_format_string(quote_attrib(self.AssemblyAccessionVersion).encode(ExternalEncoding), input_name='AssemblyAccessionVersion'), ))
        if self.Accession is not None and 'Accession' not in already_processed:
            already_processed.add('Accession')
            outfile.write(' Accession=%s' % (self.gds_format_string(quote_attrib(self.Accession).encode(ExternalEncoding), input_name='Accession'), ))
        if self.innerStart is not None and 'innerStart' not in already_processed:
            already_processed.add('innerStart')
            outfile.write(' innerStart="%s"' % self.gds_format_integer(self.innerStart, input_name='innerStart'))
        if self.outerStop is not None and 'outerStop' not in already_processed:
            already_processed.add('outerStop')
            outfile.write(' outerStop="%s"' % self.gds_format_integer(self.outerStop, input_name='outerStop'))
        if self.innerStop is not None and 'innerStop' not in already_processed:
            already_processed.add('innerStop')
            outfile.write(' innerStop="%s"' % self.gds_format_integer(self.innerStop, input_name='innerStop'))
        if self.Chr is not None and 'Chr' not in already_processed:
            already_processed.add('Chr')
            outfile.write(' Chr=%s' % (self.gds_format_string(quote_attrib(self.Chr).encode(ExternalEncoding), input_name='Chr'), ))
        if self.variantLength is not None and 'variantLength' not in already_processed:
            already_processed.add('variantLength')
            outfile.write(' variantLength="%s"' % self.gds_format_integer(self.variantLength, input_name='variantLength'))
        if self.display_start is not None and 'display_start' not in already_processed:
            already_processed.add('display_start')
            outfile.write(' display_start="%s"' % self.gds_format_integer(self.display_start, input_name='display_start'))
        if self.AssemblyStatus is not None and 'AssemblyStatus' not in already_processed:
            already_processed.add('AssemblyStatus')
            outfile.write(' AssemblyStatus=%s' % (self.gds_format_string(quote_attrib(self.AssemblyStatus).encode(ExternalEncoding), input_name='AssemblyStatus'), ))
        if self.referenceAllele is not None and 'referenceAllele' not in already_processed:
            already_processed.add('referenceAllele')
            outfile.write(' referenceAllele=%s' % (self.gds_format_string(quote_attrib(self.referenceAllele).encode(ExternalEncoding), input_name='referenceAllele'), ))
        if self.alternateAllele is not None and 'alternateAllele' not in already_processed:
            already_processed.add('alternateAllele')
            outfile.write(' alternateAllele=%s' % (self.gds_format_string(quote_attrib(self.alternateAllele).encode(ExternalEncoding), input_name='alternateAllele'), ))
        if self.Strand is not None and 'Strand' not in already_processed:
            already_processed.add('Strand')
            outfile.write(' Strand=%s' % (self.gds_format_string(quote_attrib(self.Strand).encode(ExternalEncoding), input_name='Strand'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceLocationType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SequenceLocationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.outerStart is not None and 'outerStart' not in already_processed:
            already_processed.add('outerStart')
            showIndent(outfile, level)
            outfile.write('outerStart=%d,\n' % (self.outerStart,))
        if self.Assembly is not None and 'Assembly' not in already_processed:
            already_processed.add('Assembly')
            showIndent(outfile, level)
            outfile.write('Assembly="%s",\n' % (self.Assembly,))
        if self.display_stop is not None and 'display_stop' not in already_processed:
            already_processed.add('display_stop')
            showIndent(outfile, level)
            outfile.write('display_stop=%d,\n' % (self.display_stop,))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            showIndent(outfile, level)
            outfile.write('start=%d,\n' % (self.start,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            showIndent(outfile, level)
            outfile.write('stop=%d,\n' % (self.stop,))
        if self.AssemblyAccessionVersion is not None and 'AssemblyAccessionVersion' not in already_processed:
            already_processed.add('AssemblyAccessionVersion')
            showIndent(outfile, level)
            outfile.write('AssemblyAccessionVersion="%s",\n' % (self.AssemblyAccessionVersion,))
        if self.Accession is not None and 'Accession' not in already_processed:
            already_processed.add('Accession')
            showIndent(outfile, level)
            outfile.write('Accession="%s",\n' % (self.Accession,))
        if self.innerStart is not None and 'innerStart' not in already_processed:
            already_processed.add('innerStart')
            showIndent(outfile, level)
            outfile.write('innerStart=%d,\n' % (self.innerStart,))
        if self.outerStop is not None and 'outerStop' not in already_processed:
            already_processed.add('outerStop')
            showIndent(outfile, level)
            outfile.write('outerStop=%d,\n' % (self.outerStop,))
        if self.innerStop is not None and 'innerStop' not in already_processed:
            already_processed.add('innerStop')
            showIndent(outfile, level)
            outfile.write('innerStop=%d,\n' % (self.innerStop,))
        if self.Chr is not None and 'Chr' not in already_processed:
            already_processed.add('Chr')
            showIndent(outfile, level)
            outfile.write('Chr="%s",\n' % (self.Chr,))
        if self.variantLength is not None and 'variantLength' not in already_processed:
            already_processed.add('variantLength')
            showIndent(outfile, level)
            outfile.write('variantLength=%d,\n' % (self.variantLength,))
        if self.display_start is not None and 'display_start' not in already_processed:
            already_processed.add('display_start')
            showIndent(outfile, level)
            outfile.write('display_start=%d,\n' % (self.display_start,))
        if self.AssemblyStatus is not None and 'AssemblyStatus' not in already_processed:
            already_processed.add('AssemblyStatus')
            showIndent(outfile, level)
            outfile.write('AssemblyStatus="%s",\n' % (self.AssemblyStatus,))
        if self.referenceAllele is not None and 'referenceAllele' not in already_processed:
            already_processed.add('referenceAllele')
            showIndent(outfile, level)
            outfile.write('referenceAllele="%s",\n' % (self.referenceAllele,))
        if self.alternateAllele is not None and 'alternateAllele' not in already_processed:
            already_processed.add('alternateAllele')
            showIndent(outfile, level)
            outfile.write('alternateAllele="%s",\n' % (self.alternateAllele,))
        if self.Strand is not None and 'Strand' not in already_processed:
            already_processed.add('Strand')
            showIndent(outfile, level)
            outfile.write('Strand="%s",\n' % (self.Strand,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outerStart', node)
        if value is not None and 'outerStart' not in already_processed:
            already_processed.add('outerStart')
            try:
                self.outerStart = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.outerStart < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Assembly', node)
        if value is not None and 'Assembly' not in already_processed:
            already_processed.add('Assembly')
            self.Assembly = value
        value = find_attr_value_('display_stop', node)
        if value is not None and 'display_stop' not in already_processed:
            already_processed.add('display_stop')
            try:
                self.display_stop = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.display_stop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            try:
                self.start = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.start < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            try:
                self.stop = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.stop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('AssemblyAccessionVersion', node)
        if value is not None and 'AssemblyAccessionVersion' not in already_processed:
            already_processed.add('AssemblyAccessionVersion')
            self.AssemblyAccessionVersion = value
        value = find_attr_value_('Accession', node)
        if value is not None and 'Accession' not in already_processed:
            already_processed.add('Accession')
            self.Accession = value
        value = find_attr_value_('innerStart', node)
        if value is not None and 'innerStart' not in already_processed:
            already_processed.add('innerStart')
            try:
                self.innerStart = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.innerStart < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('outerStop', node)
        if value is not None and 'outerStop' not in already_processed:
            already_processed.add('outerStop')
            try:
                self.outerStop = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.outerStop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('innerStop', node)
        if value is not None and 'innerStop' not in already_processed:
            already_processed.add('innerStop')
            try:
                self.innerStop = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.innerStop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Chr', node)
        if value is not None and 'Chr' not in already_processed:
            already_processed.add('Chr')
            self.Chr = value
        value = find_attr_value_('variantLength', node)
        if value is not None and 'variantLength' not in already_processed:
            already_processed.add('variantLength')
            try:
                self.variantLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.variantLength <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('display_start', node)
        if value is not None and 'display_start' not in already_processed:
            already_processed.add('display_start')
            try:
                self.display_start = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.display_start < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('AssemblyStatus', node)
        if value is not None and 'AssemblyStatus' not in already_processed:
            already_processed.add('AssemblyStatus')
            self.AssemblyStatus = value
        value = find_attr_value_('referenceAllele', node)
        if value is not None and 'referenceAllele' not in already_processed:
            already_processed.add('referenceAllele')
            self.referenceAllele = value
        value = find_attr_value_('alternateAllele', node)
        if value is not None and 'alternateAllele' not in already_processed:
            already_processed.add('alternateAllele')
            self.alternateAllele = value
        value = find_attr_value_('Strand', node)
        if value is not None and 'Strand' not in already_processed:
            already_processed.add('Strand')
            self.Strand = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SequenceLocationType


class IDType(GeneratedsSuper):
    """If there is an identifier, what database provides it."""
    subclass = None
    superclass = None
    def __init__(self, Source=None, valueOf_=None):
        self.original_tagname_ = None
        self.Source = _cast(None, Source)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IDType.subclass:
            return IDType.subclass(*args_, **kwargs_)
        else:
            return IDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IDType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (self.gds_format_string(quote_attrib(self.Source).encode(ExternalEncoding), input_name='Source'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            showIndent(outfile, level)
            outfile.write('Source="%s",\n' % (self.Source,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDType


class ClinVarSubmissionIDType(GeneratedsSuper):
    """Of primary use to submitters, to facilitate identification of
    records corresponding to their submissions. If not provided by a
    submitter, NCBI generates. If provided by submitter, that is
    represented in localKeyIsSubmitted."""
    subclass = None
    superclass = None
    def __init__(self, submitter=None, submitterDate=None, localKeyIsSubmitted=None, localKey=None, title=None):
        self.original_tagname_ = None
        self.submitter = _cast(None, submitter)
        if isinstance(submitterDate, basestring):
            initvalue_ = datetime_.datetime.strptime(submitterDate, '%Y-%m-%d').date()
        else:
            initvalue_ = submitterDate
        self.submitterDate = initvalue_
        self.localKeyIsSubmitted = _cast(None, localKeyIsSubmitted)
        self.localKey = _cast(None, localKey)
        self.title = _cast(None, title)
    def factory(*args_, **kwargs_):
        if ClinVarSubmissionIDType.subclass:
            return ClinVarSubmissionIDType.subclass(*args_, **kwargs_)
        else:
            return ClinVarSubmissionIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_submitter(self): return self.submitter
    def set_submitter(self, submitter): self.submitter = submitter
    def get_submitterDate(self): return self.submitterDate
    def set_submitterDate(self, submitterDate): self.submitterDate = submitterDate
    def get_localKeyIsSubmitted(self): return self.localKeyIsSubmitted
    def set_localKeyIsSubmitted(self, localKeyIsSubmitted): self.localKeyIsSubmitted = localKeyIsSubmitted
    def get_localKey(self): return self.localKey
    def set_localKey(self, localKey): self.localKey = localKey
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClinVarSubmissionIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClinVarSubmissionIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClinVarSubmissionIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClinVarSubmissionIDType'):
        if self.submitter is not None and 'submitter' not in already_processed:
            already_processed.add('submitter')
            outfile.write(' submitter=%s' % (self.gds_format_string(quote_attrib(self.submitter).encode(ExternalEncoding), input_name='submitter'), ))
        if self.submitterDate is not None and 'submitterDate' not in already_processed:
            already_processed.add('submitterDate')
            outfile.write(' submitterDate="%s"' % self.gds_format_date(self.submitterDate, input_name='submitterDate'))
        if self.localKeyIsSubmitted is not None and 'localKeyIsSubmitted' not in already_processed:
            already_processed.add('localKeyIsSubmitted')
            outfile.write(' localKeyIsSubmitted=%s' % (self.gds_format_string(quote_attrib(self.localKeyIsSubmitted).encode(ExternalEncoding), input_name='localKeyIsSubmitted'), ))
        if self.localKey is not None and 'localKey' not in already_processed:
            already_processed.add('localKey')
            outfile.write(' localKey=%s' % (self.gds_format_string(quote_attrib(self.localKey).encode(ExternalEncoding), input_name='localKey'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClinVarSubmissionIDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ClinVarSubmissionIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.submitter is not None and 'submitter' not in already_processed:
            already_processed.add('submitter')
            showIndent(outfile, level)
            outfile.write('submitter="%s",\n' % (self.submitter,))
        if self.submitterDate is not None and 'submitterDate' not in already_processed:
            already_processed.add('submitterDate')
            showIndent(outfile, level)
            outfile.write('submitterDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.submitterDate, input_name='submitterDate'))
        if self.localKeyIsSubmitted is not None and 'localKeyIsSubmitted' not in already_processed:
            already_processed.add('localKeyIsSubmitted')
            showIndent(outfile, level)
            outfile.write('localKeyIsSubmitted="%s",\n' % (self.localKeyIsSubmitted,))
        if self.localKey is not None and 'localKey' not in already_processed:
            already_processed.add('localKey')
            showIndent(outfile, level)
            outfile.write('localKey="%s",\n' % (self.localKey,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            showIndent(outfile, level)
            outfile.write('title="%s",\n' % (self.title,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('submitter', node)
        if value is not None and 'submitter' not in already_processed:
            already_processed.add('submitter')
            self.submitter = value
        value = find_attr_value_('submitterDate', node)
        if value is not None and 'submitterDate' not in already_processed:
            already_processed.add('submitterDate')
            try:
                self.submitterDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (submitterDate): %s' % exp)
        value = find_attr_value_('localKeyIsSubmitted', node)
        if value is not None and 'localKeyIsSubmitted' not in already_processed:
            already_processed.add('localKeyIsSubmitted')
            self.localKeyIsSubmitted = value
        value = find_attr_value_('localKey', node)
        if value is not None and 'localKey' not in already_processed:
            already_processed.add('localKey')
            self.localKey = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClinVarSubmissionIDType


class ClinVarAccessionType(GeneratedsSuper):
    """RCV accessions aggregate data from each submission. Each submission
    is assigned an accession of beginning with 'SCV'"""
    subclass = None
    superclass = None
    def __init__(self, Acc=None, OrgID=None, DateUpdated=None, Version=None, Type=None):
        self.original_tagname_ = None
        self.Acc = _cast(None, Acc)
        self.OrgID = _cast(int, OrgID)
        if isinstance(DateUpdated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateUpdated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateUpdated
        self.DateUpdated = initvalue_
        self.Version = _cast(int, Version)
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if ClinVarAccessionType.subclass:
            return ClinVarAccessionType.subclass(*args_, **kwargs_)
        else:
            return ClinVarAccessionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Acc(self): return self.Acc
    def set_Acc(self, Acc): self.Acc = Acc
    def get_OrgID(self): return self.OrgID
    def set_OrgID(self, OrgID): self.OrgID = OrgID
    def get_DateUpdated(self): return self.DateUpdated
    def set_DateUpdated(self, DateUpdated): self.DateUpdated = DateUpdated
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClinVarAccessionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClinVarAccessionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClinVarAccessionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClinVarAccessionType'):
        if self.Acc is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            outfile.write(' Acc=%s' % (self.gds_format_string(quote_attrib(self.Acc).encode(ExternalEncoding), input_name='Acc'), ))
        if self.OrgID is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            outfile.write(' OrgID="%s"' % self.gds_format_integer(self.OrgID, input_name='OrgID'))
        if self.DateUpdated is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            outfile.write(' DateUpdated="%s"' % self.gds_format_date(self.DateUpdated, input_name='DateUpdated'))
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version="%s"' % self.gds_format_integer(self.Version, input_name='Version'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClinVarAccessionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ClinVarAccessionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Acc is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            showIndent(outfile, level)
            outfile.write('Acc="%s",\n' % (self.Acc,))
        if self.OrgID is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            showIndent(outfile, level)
            outfile.write('OrgID=%d,\n' % (self.OrgID,))
        if self.DateUpdated is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            showIndent(outfile, level)
            outfile.write('DateUpdated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateUpdated, input_name='DateUpdated'))
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % (self.Version,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Acc', node)
        if value is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            self.Acc = value
        value = find_attr_value_('OrgID', node)
        if value is not None and 'OrgID' not in already_processed:
            already_processed.add('OrgID')
            try:
                self.OrgID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('DateUpdated', node)
        if value is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            try:
                self.DateUpdated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateUpdated): %s' % exp)
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            try:
                self.Version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClinVarAccessionType


class AdditionalSubmittersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SubmitterDescription=None):
        self.original_tagname_ = None
        if SubmitterDescription is None:
            self.SubmitterDescription = []
        else:
            self.SubmitterDescription = SubmitterDescription
    def factory(*args_, **kwargs_):
        if AdditionalSubmittersType.subclass:
            return AdditionalSubmittersType.subclass(*args_, **kwargs_)
        else:
            return AdditionalSubmittersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubmitterDescription(self): return self.SubmitterDescription
    def set_SubmitterDescription(self, SubmitterDescription): self.SubmitterDescription = SubmitterDescription
    def add_SubmitterDescription(self, value): self.SubmitterDescription.append(value)
    def insert_SubmitterDescription_at(self, index, value): self.SubmitterDescription.insert(index, value)
    def replace_SubmitterDescription_at(self, index, value): self.SubmitterDescription[index] = value
    def hasContent_(self):
        if (
            self.SubmitterDescription
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdditionalSubmittersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalSubmittersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdditionalSubmittersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdditionalSubmittersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdditionalSubmittersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubmitterDescription_ in self.SubmitterDescription:
            SubmitterDescription_.export(outfile, level, namespace_, name_='SubmitterDescription', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AdditionalSubmittersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SubmitterDescription=[\n')
        level += 1
        for SubmitterDescription_ in self.SubmitterDescription:
            showIndent(outfile, level)
            outfile.write('model_.SubmitterType(\n')
            SubmitterDescription_.exportLiteral(outfile, level, name_='SubmitterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubmitterDescription':
            obj_ = SubmitterType.factory()
            obj_.build(child_)
            self.SubmitterDescription.append(obj_)
            obj_.original_tagname_ = 'SubmitterDescription'
# end class AdditionalSubmittersType


class CustomAssertionScoreType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None, Citation=None, XRef=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.Value = _cast(None, Value)
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
    def factory(*args_, **kwargs_):
        if CustomAssertionScoreType.subclass:
            return CustomAssertionScoreType.subclass(*args_, **kwargs_)
        else:
            return CustomAssertionScoreType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Citation or
            self.XRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomAssertionScoreType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomAssertionScoreType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomAssertionScoreType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomAssertionScoreType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(' Value=%s' % (self.gds_format_string(quote_attrib(self.Value).encode(ExternalEncoding), input_name='Value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomAssertionScoreType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomAssertionScoreType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            showIndent(outfile, level)
            outfile.write('Value="%s",\n' % (self.Value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
# end class CustomAssertionScoreType


class AttributeSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType.subclass:
            return AttributeSetType.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType2(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType2.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType


class AttributeType2(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType2, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType2.subclass:
            return AttributeType2.subclass(*args_, **kwargs_)
        else:
            return AttributeType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType2'):
        super(AttributeType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType2')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType2', fromsubclass_=False, pretty_print=True):
        super(AttributeType2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType2, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType2


class ClinVarAccessionType3(GeneratedsSuper):
    """The accession assigned by ClinVar.A new version of an SCV accession
    is assigned with an update from the submitter. A new version of
    an RCV accession is assigned when the set of ClinVarAssertions
    is changed, either by a change in version or by addition of a
    new submission."""
    subclass = None
    superclass = None
    def __init__(self, Acc=None, DateUpdated=None, Version=None, Type=None):
        self.original_tagname_ = None
        self.Acc = _cast(None, Acc)
        if isinstance(DateUpdated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateUpdated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateUpdated
        self.DateUpdated = initvalue_
        self.Version = _cast(int, Version)
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if ClinVarAccessionType3.subclass:
            return ClinVarAccessionType3.subclass(*args_, **kwargs_)
        else:
            return ClinVarAccessionType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Acc(self): return self.Acc
    def set_Acc(self, Acc): self.Acc = Acc
    def get_DateUpdated(self): return self.DateUpdated
    def set_DateUpdated(self, DateUpdated): self.DateUpdated = DateUpdated
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ClinVarAccessionType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClinVarAccessionType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ClinVarAccessionType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClinVarAccessionType3'):
        if self.Acc is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            outfile.write(' Acc=%s' % (self.gds_format_string(quote_attrib(self.Acc).encode(ExternalEncoding), input_name='Acc'), ))
        if self.DateUpdated is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            outfile.write(' DateUpdated="%s"' % self.gds_format_date(self.DateUpdated, input_name='DateUpdated'))
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version="%s"' % self.gds_format_integer(self.Version, input_name='Version'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ClinVarAccessionType3', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ClinVarAccessionType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Acc is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            showIndent(outfile, level)
            outfile.write('Acc="%s",\n' % (self.Acc,))
        if self.DateUpdated is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            showIndent(outfile, level)
            outfile.write('DateUpdated=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.DateUpdated, input_name='DateUpdated'))
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            showIndent(outfile, level)
            outfile.write('Version=%d,\n' % (self.Version,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Acc', node)
        if value is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            self.Acc = value
        value = find_attr_value_('DateUpdated', node)
        if value is not None and 'DateUpdated' not in already_processed:
            already_processed.add('DateUpdated')
            try:
                self.DateUpdated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateUpdated): %s' % exp)
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            try:
                self.Version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ClinVarAccessionType3


class AttributeSetType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType5.subclass:
            return AttributeSetType5.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType6(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType6.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType5


class AttributeType6(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType6, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType6.subclass:
            return AttributeType6.subclass(*args_, **kwargs_)
        else:
            return AttributeType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType6, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType6')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType6'):
        super(AttributeType6, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType6')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType6', fromsubclass_=False, pretty_print=True):
        super(AttributeType6, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType6, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType6, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType6, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType6


class MeasureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Name=None, Symbol=None, AttributeSet=None, CytogeneticLocation=None, SequenceLocation=None, MeasureRelationship=None, Citation=None, XRef=None, Comment=None, Source=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if CytogeneticLocation is None:
            self.CytogeneticLocation = []
        else:
            self.CytogeneticLocation = CytogeneticLocation
        if SequenceLocation is None:
            self.SequenceLocation = []
        else:
            self.SequenceLocation = SequenceLocation
        if MeasureRelationship is None:
            self.MeasureRelationship = []
        else:
            self.MeasureRelationship = MeasureRelationship
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
    def factory(*args_, **kwargs_):
        if MeasureType.subclass:
            return MeasureType.subclass(*args_, **kwargs_)
        else:
            return MeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_CytogeneticLocation(self): return self.CytogeneticLocation
    def set_CytogeneticLocation(self, CytogeneticLocation): self.CytogeneticLocation = CytogeneticLocation
    def add_CytogeneticLocation(self, value): self.CytogeneticLocation.append(value)
    def insert_CytogeneticLocation_at(self, index, value): self.CytogeneticLocation.insert(index, value)
    def replace_CytogeneticLocation_at(self, index, value): self.CytogeneticLocation[index] = value
    def get_SequenceLocation(self): return self.SequenceLocation
    def set_SequenceLocation(self, SequenceLocation): self.SequenceLocation = SequenceLocation
    def add_SequenceLocation(self, value): self.SequenceLocation.append(value)
    def insert_SequenceLocation_at(self, index, value): self.SequenceLocation.insert(index, value)
    def replace_SequenceLocation_at(self, index, value): self.SequenceLocation[index] = value
    def get_MeasureRelationship(self): return self.MeasureRelationship
    def set_MeasureRelationship(self, MeasureRelationship): self.MeasureRelationship = MeasureRelationship
    def add_MeasureRelationship(self, value): self.MeasureRelationship.append(value)
    def insert_MeasureRelationship_at(self, index, value): self.MeasureRelationship.insert(index, value)
    def replace_MeasureRelationship_at(self, index, value): self.MeasureRelationship[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source_at(self, index, value): self.Source.insert(index, value)
    def replace_Source_at(self, index, value): self.Source[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.CytogeneticLocation or
            self.SequenceLocation or
            self.MeasureRelationship or
            self.Citation or
            self.XRef or
            self.Comment or
            self.Source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeasureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for CytogeneticLocation_ in self.CytogeneticLocation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCytogeneticLocation>%s</%sCytogeneticLocation>%s' % (namespace_, self.gds_format_string(quote_xml(CytogeneticLocation_).encode(ExternalEncoding), input_name='CytogeneticLocation'), namespace_, eol_))
        for SequenceLocation_ in self.SequenceLocation:
            SequenceLocation_.export(outfile, level, namespace_, name_='SequenceLocation', pretty_print=pretty_print)
        for MeasureRelationship_ in self.MeasureRelationship:
            MeasureRelationship_.export(outfile, level, namespace_, name_='MeasureRelationship', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for Source_ in self.Source:
            Source_.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeasureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType7(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType7')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CytogeneticLocation=[\n')
        level += 1
        for CytogeneticLocation_ in self.CytogeneticLocation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CytogeneticLocation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SequenceLocation=[\n')
        level += 1
        for SequenceLocation_ in self.SequenceLocation:
            showIndent(outfile, level)
            outfile.write('model_.SequenceLocationType(\n')
            SequenceLocation_.exportLiteral(outfile, level, name_='SequenceLocationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MeasureRelationship=[\n')
        level += 1
        for MeasureRelationship_ in self.MeasureRelationship:
            showIndent(outfile, level)
            outfile.write('model_.MeasureRelationshipType(\n')
            MeasureRelationship_.exportLiteral(outfile, level, name_='MeasureRelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('model_.DataSourceType(\n')
            Source_.exportLiteral(outfile, level, name_='DataSourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType7.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'CytogeneticLocation':
            CytogeneticLocation_ = child_.text
            CytogeneticLocation_ = self.gds_validate_string(CytogeneticLocation_, node, 'CytogeneticLocation')
            self.CytogeneticLocation.append(CytogeneticLocation_)
        elif nodeName_ == 'SequenceLocation':
            obj_ = SequenceLocationType.factory()
            obj_.build(child_)
            self.SequenceLocation.append(obj_)
            obj_.original_tagname_ = 'SequenceLocation'
        elif nodeName_ == 'MeasureRelationship':
            obj_ = MeasureRelationshipType.factory()
            obj_.build(child_)
            self.MeasureRelationship.append(obj_)
            obj_.original_tagname_ = 'MeasureRelationship'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Source':
            obj_ = DataSourceType.factory()
            obj_.build(child_)
            self.Source.append(obj_)
            obj_.original_tagname_ = 'Source'
# end class MeasureType


class AttributeSetType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType7.subclass:
            return AttributeSetType7.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType7'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType8(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType8.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType7


class AttributeType8(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, Change=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType8, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.Change = _cast(None, Change)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType8.subclass:
            return AttributeType8.subclass(*args_, **kwargs_)
        else:
            return AttributeType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Change(self): return self.Change
    def set_Change(self, Change): self.Change = Change
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType8, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType8')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType8'):
        super(AttributeType8, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType8')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Change is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            outfile.write(' Change=%s' % (self.gds_format_string(quote_attrib(self.Change).encode(ExternalEncoding), input_name='Change'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType8', fromsubclass_=False, pretty_print=True):
        super(AttributeType8, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType8'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Change is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            showIndent(outfile, level)
            outfile.write('Change="%s",\n' % (self.Change,))
        super(AttributeType8, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType8, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Change', node)
        if value is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            self.Change = value
        super(AttributeType8, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType8


class MeasureRelationshipType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Name=None, Symbol=None, AttributeSet=None, SequenceLocation=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if SequenceLocation is None:
            self.SequenceLocation = []
        else:
            self.SequenceLocation = SequenceLocation
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if MeasureRelationshipType.subclass:
            return MeasureRelationshipType.subclass(*args_, **kwargs_)
        else:
            return MeasureRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_SequenceLocation(self): return self.SequenceLocation
    def set_SequenceLocation(self, SequenceLocation): self.SequenceLocation = SequenceLocation
    def add_SequenceLocation(self, value): self.SequenceLocation.append(value)
    def insert_SequenceLocation_at(self, index, value): self.SequenceLocation.insert(index, value)
    def replace_SequenceLocation_at(self, index, value): self.SequenceLocation[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.SequenceLocation or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeasureRelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasureRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeasureRelationshipType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeasureRelationshipType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='MeasureRelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for SequenceLocation_ in self.SequenceLocation:
            SequenceLocation_.export(outfile, level, namespace_, name_='SequenceLocation', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeasureRelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType9(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType9')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SequenceLocation=[\n')
        level += 1
        for SequenceLocation_ in self.SequenceLocation:
            showIndent(outfile, level)
            outfile.write('model_.SequenceLocationType(\n')
            SequenceLocation_.exportLiteral(outfile, level, name_='SequenceLocationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType9.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'SequenceLocation':
            obj_ = SequenceLocationType.factory()
            obj_.build(child_)
            self.SequenceLocation.append(obj_)
            obj_.original_tagname_ = 'SequenceLocation'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class MeasureRelationshipType


class AttributeSetType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
    def factory(*args_, **kwargs_):
        if AttributeSetType9.subclass:
            return AttributeSetType9.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType9', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType9'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType10(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType10.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
# end class AttributeSetType9


class AttributeType10(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType10, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType10.subclass:
            return AttributeType10.subclass(*args_, **kwargs_)
        else:
            return AttributeType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType10, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType10', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType10')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType10'):
        super(AttributeType10, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType10')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType10', fromsubclass_=False, pretty_print=True):
        super(AttributeType10, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType10'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType10, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType10, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType10, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType10


class AttributeSetType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType11.subclass:
            return AttributeSetType11.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType11', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType11'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType12(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType12.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType11


class AttributeType12(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, Change=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType12, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.Change = _cast(None, Change)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType12.subclass:
            return AttributeType12.subclass(*args_, **kwargs_)
        else:
            return AttributeType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Change(self): return self.Change
    def set_Change(self, Change): self.Change = Change
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType12, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType12', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType12')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType12', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType12'):
        super(AttributeType12, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType12')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.Change is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            outfile.write(' Change=%s' % (self.gds_format_string(quote_attrib(self.Change).encode(ExternalEncoding), input_name='Change'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType12', fromsubclass_=False, pretty_print=True):
        super(AttributeType12, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType12'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.Change is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            showIndent(outfile, level)
            outfile.write('Change="%s",\n' % (self.Change,))
        super(AttributeType12, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType12, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Change', node)
        if value is not None and 'Change' not in already_processed:
            already_processed.add('Change')
            self.Change = value
        super(AttributeType12, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType12


class AttributeSetType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType13.subclass:
            return AttributeSetType13.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType13', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType13'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType14(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType14.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType13


class AttributeType14(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType14, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType14.subclass:
            return AttributeType14.subclass(*args_, **kwargs_)
        else:
            return AttributeType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType14, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType14', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType14')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType14'):
        super(AttributeType14, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType14')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType14', fromsubclass_=False, pretty_print=True):
        super(AttributeType14, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType14'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType14, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType14, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType14, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType14


class AttributeSetType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType15.subclass:
            return AttributeSetType15.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType15', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType15'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType15'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType16(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType16.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType15


class AttributeType16(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType16, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType16.subclass:
            return AttributeType16.subclass(*args_, **kwargs_)
        else:
            return AttributeType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType16')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType16'):
        super(AttributeType16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType16')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType16', fromsubclass_=False, pretty_print=True):
        super(AttributeType16, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType16'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType16, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType16, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType16


class TraitRelationshipType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Name=None, Symbol=None, AttributeSet=None, Citation=None, XRef=None, Source=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(int, ID)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
    def factory(*args_, **kwargs_):
        if TraitRelationshipType.subclass:
            return TraitRelationshipType.subclass(*args_, **kwargs_)
        else:
            return TraitRelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol_at(self, index, value): self.Symbol.insert(index, value)
    def replace_Symbol_at(self, index, value): self.Symbol[index] = value
    def get_AttributeSet(self): return self.AttributeSet
    def set_AttributeSet(self, AttributeSet): self.AttributeSet = AttributeSet
    def add_AttributeSet(self, value): self.AttributeSet.append(value)
    def insert_AttributeSet_at(self, index, value): self.AttributeSet.insert(index, value)
    def replace_AttributeSet_at(self, index, value): self.AttributeSet[index] = value
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source_at(self, index, value): self.Source.insert(index, value)
    def replace_Source_at(self, index, value): self.Source[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            self.Name or
            self.Symbol or
            self.AttributeSet or
            self.Citation or
            self.XRef or
            self.Source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TraitRelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TraitRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TraitRelationshipType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TraitRelationshipType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='TraitRelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol', pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            AttributeSet_.export(outfile, level, namespace_, name_='AttributeSet', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Source_ in self.Source:
            Source_.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TraitRelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Name_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SetElementSetType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SetElementSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttributeSet=[\n')
        level += 1
        for AttributeSet_ in self.AttributeSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeSetType17(\n')
            AttributeSet_.exportLiteral(outfile, level, name_='AttributeSetType17')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('model_.DataSourceType(\n')
            Source_.exportLiteral(outfile, level, name_='DataSourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType17.factory()
            obj_.build(child_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Source':
            obj_ = DataSourceType.factory()
            obj_.build(child_)
            self.Source.append(obj_)
            obj_.original_tagname_ = 'Source'
# end class TraitRelationshipType


class AttributeSetType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if AttributeSetType17.subclass:
            return AttributeSetType17.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeSetType17', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeSetType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeSetType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeSetType17'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeSetType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeSetType17'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType18(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType18.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class AttributeSetType17


class AttributeType18(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType18, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType18.subclass:
            return AttributeType18.subclass(*args_, **kwargs_)
        else:
            return AttributeType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType18, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType18', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType18')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType18'):
        super(AttributeType18, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType18')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType18', fromsubclass_=False, pretty_print=True):
        super(AttributeType18, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType18'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType18, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType18, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType18, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType18


class ElementValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ElementValueType.subclass:
            return ElementValueType.subclass(*args_, **kwargs_)
        else:
            return ElementValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ElementValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ElementValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElementValueType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElementValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ElementValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElementValueType


class MethodAttributeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None):
        self.original_tagname_ = None
        self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if MethodAttributeType.subclass:
            return MethodAttributeType.subclass(*args_, **kwargs_)
        else:
            return MethodAttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def hasContent_(self):
        if (
            self.Attribute is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MethodAttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MethodAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MethodAttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MethodAttributeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MethodAttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MethodAttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType19(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType19.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
# end class MethodAttributeType


class AttributeType19(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType19, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType19.subclass:
            return AttributeType19.subclass(*args_, **kwargs_)
        else:
            return AttributeType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType19, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType19', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType19')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType19', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType19'):
        super(AttributeType19, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType19')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType19', fromsubclass_=False, pretty_print=True):
        super(AttributeType19, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType19'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType19, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType19, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType19, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType19


class MethodType20(MethodType):
    subclass = None
    superclass = MethodType
    def __init__(self, NamePlatform=None, TypePlatform=None, Purpose=None, ResultType=None, MinReported=None, MaxReported=None, ReferenceStandard=None, Citation=None, XRef=None, Description=None, Software=None, SourceType=None, MethodType_member=None, MethodAttribute=None, MethodResult=None, Type=None):
        self.original_tagname_ = None
        super(MethodType20, self).__init__(NamePlatform, TypePlatform, Purpose, ResultType, MinReported, MaxReported, ReferenceStandard, Citation, XRef, Description, Software, SourceType, MethodType_member, MethodAttribute, MethodResult, )
        self.Type = Type
        self.validate_TypeType(self.Type)
    def factory(*args_, **kwargs_):
        if MethodType20.subclass:
            return MethodType20.subclass(*args_, **kwargs_)
        else:
            return MethodType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_TypeType(self, value):
        # Validate type TypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['literature only', 'reference population', 'case-control', 'clinical testing', 'in vitro', 'in vivo', 'inferred from source', 'research']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            super(MethodType20, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MethodType20', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MethodType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MethodType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MethodType20'):
        super(MethodType20, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MethodType20')
    def exportChildren(self, outfile, level, namespace_='', name_='MethodType20', fromsubclass_=False, pretty_print=True):
        super(MethodType20, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sType>%s</%sType>%s' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MethodType20'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MethodType20, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MethodType20, self).exportLiteralChildren(outfile, level, name_)
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MethodType20, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            self.validate_TypeType(self.Type)    # validate type TypeType
        super(MethodType20, self).buildChildren(child_, node, nodeName_, True)
# end class MethodType20


class ObservedDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Attribute=None, Severity=None, Citation=None, XRef=None, Comment=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.Attribute = Attribute
        self.Severity = Severity
        self.validate_SeverityType(self.Severity)
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if ObservedDataType.subclass:
            return ObservedDataType.subclass(*args_, **kwargs_)
        else:
            return ObservedDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Severity(self): return self.Severity
    def set_Severity(self, Severity): self.Severity = Severity
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def add_Citation(self, value): self.Citation.append(value)
    def insert_Citation_at(self, index, value): self.Citation.insert(index, value)
    def replace_Citation_at(self, index, value): self.Citation[index] = value
    def get_XRef(self): return self.XRef
    def set_XRef(self, XRef): self.XRef = XRef
    def add_XRef(self, value): self.XRef.append(value)
    def insert_XRef_at(self, index, value): self.XRef.insert(index, value)
    def replace_XRef_at(self, index, value): self.XRef[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_SeverityType(self, value):
        # Validate type SeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mild', 'moderate', 'severe']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SeverityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.Severity is not None or
            self.Citation or
            self.XRef or
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObservedDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservedDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObservedDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObservedDataType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='', name_='ObservedDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.Severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeverity>%s</%sSeverity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Severity).encode(ExternalEncoding), input_name='Severity'), namespace_, eol_))
        for Citation_ in self.Citation:
            Citation_.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
        for XRef_ in self.XRef:
            XRef_.export(outfile, level, namespace_, name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObservedDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType21(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Severity is not None:
            showIndent(outfile, level)
            outfile.write('Severity=%s,\n' % quote_python(self.Severity).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Citation=[\n')
        level += 1
        for Citation_ in self.Citation:
            showIndent(outfile, level)
            outfile.write('model_.CitationType(\n')
            Citation_.exportLiteral(outfile, level, name_='CitationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('XRef=[\n')
        level += 1
        for XRef_ in self.XRef:
            showIndent(outfile, level)
            outfile.write('model_.XrefType(\n')
            XRef_.exportLiteral(outfile, level, name_='XrefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.CommentType(\n')
            Comment_.exportLiteral(outfile, level, name_='CommentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = AttributeType21.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Severity':
            Severity_ = child_.text
            Severity_ = self.gds_validate_string(Severity_, node, 'Severity')
            self.Severity = Severity_
            self.validate_SeverityType(self.Severity)    # validate type SeverityType
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory()
            obj_.build(child_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class ObservedDataType


class AttributeType21(AttributeType):
    subclass = None
    superclass = AttributeType
    def __init__(self, integerValue=None, dateValue=None, Type=None, valueOf_=None):
        self.original_tagname_ = None
        super(AttributeType21, self).__init__(integerValue, dateValue, valueOf_, )
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributeType21.subclass:
            return AttributeType21.subclass(*args_, **kwargs_)
        else:
            return AttributeType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AttributeType21, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType21', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType21')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType21', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType21'):
        super(AttributeType21, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType21')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType21', fromsubclass_=False, pretty_print=True):
        super(AttributeType21, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AttributeType21'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        super(AttributeType21, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AttributeType21, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(AttributeType21, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributeType21


class SampleDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None, Citation=None):
        self.original_tagname_ = None
        self.Description = Description
        self.Citation = Citation
    def factory(*args_, **kwargs_):
        if SampleDescriptionType.subclass:
            return SampleDescriptionType.subclass(*args_, **kwargs_)
        else:
            return SampleDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Citation(self): return self.Citation
    def set_Citation(self, Citation): self.Citation = Citation
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Citation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SampleDescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SampleDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SampleDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SampleDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Citation is not None:
            self.Citation.export(outfile, level, namespace_, name_='Citation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SampleDescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.CommentType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Citation is not None:
            showIndent(outfile, level)
            outfile.write('Citation=model_.CitationType(\n')
            self.Citation.exportLiteral(outfile, level, name_='Citation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = CommentType.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory()
            obj_.build(child_)
            self.Citation = obj_
            obj_.original_tagname_ = 'Citation'
# end class SampleDescriptionType


class SpeciesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxonomyId=None, valueOf_=None):
        self.original_tagname_ = None
        self.TaxonomyId = _cast(int, TaxonomyId)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SpeciesType.subclass:
            return SpeciesType.subclass(*args_, **kwargs_)
        else:
            return SpeciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxonomyId(self): return self.TaxonomyId
    def set_TaxonomyId(self, TaxonomyId): self.TaxonomyId = TaxonomyId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpeciesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpeciesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpeciesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpeciesType'):
        if self.TaxonomyId is not None and 'TaxonomyId' not in already_processed:
            already_processed.add('TaxonomyId')
            outfile.write(' TaxonomyId="%s"' % self.gds_format_integer(self.TaxonomyId, input_name='TaxonomyId'))
    def exportChildren(self, outfile, level, namespace_='', name_='SpeciesType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SpeciesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TaxonomyId is not None and 'TaxonomyId' not in already_processed:
            already_processed.add('TaxonomyId')
            showIndent(outfile, level)
            outfile.write('TaxonomyId=%d,\n' % (self.TaxonomyId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TaxonomyId', node)
        if value is not None and 'TaxonomyId' not in already_processed:
            already_processed.add('TaxonomyId')
            try:
                self.TaxonomyId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SpeciesType


class AgeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, age_unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.age_unit = _cast(None, age_unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AgeType.subclass:
            return AgeType.subclass(*args_, **kwargs_)
        else:
            return AgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_age_unit(self): return self.age_unit
    def set_age_unit(self, age_unit): self.age_unit = age_unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AgeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AgeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AgeType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (self.gds_format_string(quote_attrib(self.Type).encode(ExternalEncoding), input_name='Type'), ))
        if self.age_unit is not None and 'age_unit' not in already_processed:
            already_processed.add('age_unit')
            outfile.write(' age_unit=%s' % (self.gds_format_string(quote_attrib(self.age_unit).encode(ExternalEncoding), input_name='age_unit'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AgeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AgeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type="%s",\n' % (self.Type,))
        if self.age_unit is not None and 'age_unit' not in already_processed:
            already_processed.add('age_unit')
            showIndent(outfile, level)
            outfile.write('age_unit="%s",\n' % (self.age_unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('age_unit', node)
        if value is not None and 'age_unit' not in already_processed:
            already_processed.add('age_unit')
            self.age_unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgeType


GDSClassesMapping = {
    'ClinVarAssertion': MeasureTraitType,
    'MeasureRelationship': MeasureRelationshipType,
    'SequenceLocation': SequenceLocationType,
    'AttributeSet': AttributeSetType17,
    'Assertion': AssertionTypeRCV,
    'AdditionalSubmitters': AdditionalSubmittersType,
    'Co-occurrenceSet': Co_occurrenceType,
    'Source': DataSourceType,
    'Description': CommentType,
    'TraitSet': TraitSetType,
    'Method': MethodType20,
    'ElementValue': ElementValueType,
    'ClinVarAccession': ClinVarAccessionType3,
    'Trait': TraitType,
    'Symbol': SetElementSetType,
    'Explanation': CommentType,
    'SampleDescription': SampleDescriptionType,
    'ClinicalSignificance': ClinicalSignificanceType,
    'ClinVarSet': PublicSetType,
    'CustomAssertionScore': CustomAssertionScoreType,
    'Name': SetElementSetType,
    'MethodAttribute': MethodAttributeType,
    'ObservedIn': ObservationSet,
    'Age': AgeType,
    'Software': SoftwareSet,
    'ReleaseSet': ReleaseType,
    'Indication': IndicationType,
    'ReferenceClinVarAssertion': ReferenceAssertionType,
    'ID': IDType,
    'TraitRelationship': TraitRelationshipType,
    'Comment': CommentType,
    'XRef': XrefType,
    'ClinVarSubmissionID': ClinVarSubmissionIDType,
    'SubmitterDescription': SubmitterType,
    'Citation': CitationType,
    'MethodResult': AttributeType,
    'FamilyData': FamilyInfo,
    'Sample': SampleType,
    'ExternalID': XrefType,
    'AlleleDescSet': AlleleDescType,
    'Measure': MeasureType,
    'Attribute': AttributeType21,
    'MeasureSet': MeasureSetType,
    'ObservedData': ObservedDataType,
    'Species': SpeciesType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReleaseType'
        rootClass = ReleaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReleaseType'
        rootClass = ReleaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReleaseType'
        rootClass = ReleaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReleaseType'
        rootClass = ReleaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from clinvar import *\n\n')
        sys.stdout.write('import clinvar as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdditionalSubmittersType",
    "AgeType",
    "AlleleDescType",
    "AssertionTypeRCV",
    "AssertionTypeSCV",
    "AttributeSetType",
    "AttributeSetType11",
    "AttributeSetType13",
    "AttributeSetType15",
    "AttributeSetType17",
    "AttributeSetType5",
    "AttributeSetType7",
    "AttributeSetType9",
    "AttributeType",
    "AttributeType10",
    "AttributeType12",
    "AttributeType14",
    "AttributeType16",
    "AttributeType18",
    "AttributeType19",
    "AttributeType2",
    "AttributeType21",
    "AttributeType6",
    "AttributeType8",
    "CitationType",
    "ClinVarAccessionType",
    "ClinVarAccessionType3",
    "ClinVarSubmissionIDType",
    "ClinicalSignificanceType",
    "ClinicalSignificanceTypeSCV",
    "Co_occurrenceType",
    "CommentType",
    "CustomAssertionScoreType",
    "DataSourceType",
    "ElementValueType",
    "FamilyInfo",
    "IDType",
    "IndicationType",
    "MeasureRelationshipType",
    "MeasureSetType",
    "MeasureTraitType",
    "MeasureType",
    "MethodAttributeType",
    "MethodType",
    "MethodType20",
    "ObservationSet",
    "ObservedDataType",
    "PublicSetType",
    "ReferenceAssertionType",
    "ReleaseType",
    "SampleDescriptionType",
    "SampleType",
    "SequenceLocationType",
    "SetElementSetType",
    "SoftwareSet",
    "SpeciesType",
    "SubmitterType",
    "TraitRelationshipType",
    "TraitSetType",
    "TraitType",
    "XrefType"
]
